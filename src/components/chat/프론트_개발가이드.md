# ì±„íŒ… ì‹œìŠ¤í…œ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œì ê°€ì´ë“œ (React.js/Next.js)

ì´ ë¬¸ì„œëŠ” ì±„íŒ… ì‹œìŠ¤í…œ APIë¥¼ ì‚¬ìš©í•˜ì—¬ React.js/Next.js í”„ë¡ íŠ¸ì—”ë“œ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•˜ëŠ” ë° í•„ìš”í•œ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

## 1. API ê°œìš”

ì±„íŒ… APIëŠ” RESTful APIì™€ WebSocketì„ ì¡°í•©í•˜ì—¬ ì œê³µë©ë‹ˆë‹¤:

- **RESTful API**: ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ, ë©”ì‹œì§€ ì¡°íšŒ, íŒŒì¼ ì—…ë¡œë“œ ë“± ì¼ë°˜ ì‘ì—…
- **WebSocket**: ì‹¤ì‹œê°„ ì±„íŒ…, ì±„íŒ…ë°© ëª©ë¡ ì—…ë°ì´íŠ¸, ìƒíƒœ ë³€ê²½ ì•Œë¦¼ ë“±
- **JWT ì¸ì¦**: Bearer í† í° ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ

### 1.1 ê¸°ë³¸ URL

- **API Base URL**: `https://www.tigerbk.com/chat-api`
- **WebSocket Base URL**: `wss://www.tigerbk.com/chat-api`

### 1.2 React.js/Next.js í™˜ê²½ ì„¤ì •

#### í•„ìš”í•œ ì˜ì¡´ì„± ì„¤ì¹˜

```bash
npm install axios socket.io-client
# ë˜ëŠ”
yarn add axios socket.io-client
```

#### í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (.env.local)

```env
NEXT_PUBLIC_CHAT_API_URL=https://www.tigerbk.com/chat-api
NEXT_PUBLIC_CHAT_WS_URL=wss://www.tigerbk.com/chat-api
```

## 2. í‘œì¤€ ì‘ë‹µ í˜•ì‹

ëª¨ë“  HTTP API ì‘ë‹µì€ ë‹¤ìŒ í˜•ì‹ì„ ë”°ë¦…ë‹ˆë‹¤:

```json
{
  "success": true|false,
  "message": "ìš”ì²­ ì²˜ë¦¬ ë©”ì‹œì§€",
  "data": { ... },  // ì„±ê³µ ì‹œ ê²°ê³¼ ë°ì´í„°
  "error": "ì—ëŸ¬ ë©”ì‹œì§€"  // ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€
}
```

## 3. ì¸ì¦ ì‹œìŠ¤í…œ

ì±„íŒ… ì‹œìŠ¤í…œì€ JWT(JSON Web Token) ê¸°ë°˜ ì¸ì¦ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

### 3.1 ì¸ì¦ ë°©ì‹

- **HTTP API**: `Authorization: Bearer {token}` í—¤ë” ì‚¬ìš©
- **WebSocket**: ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë¡œ í† í° ì „ë‹¬ (`?token={token}`)
- **í† í° ë§Œë£Œ**: 7ì¼ (ìë™ ê°±ì‹  ê¶Œì¥)

### 3.2 ë¡œê·¸ì¸ API

**ìš”ì²­**:

- URL: `POST /auth/login`
- Content-Type: `application/json`
- ìš”ì²­ ë³¸ë¬¸:

```json
{
  "userId": "user123",
  "userType": "APP" // "APP" ë˜ëŠ” "WEB"
}
```

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "ë¡œê·¸ì¸ì´ ì„±ê³µí–ˆìŠµë‹ˆë‹¤.",
  "data": {
    "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 604800
  }
}
```

### 3.3 React Hook ì˜ˆì‹œ

```typescript
// hooks/useAuth.ts
import { useState, useEffect } from "react";
import axios from "axios";

interface AuthState {
  token: string | null;
  userId: string | null;
  userType: "APP" | "WEB" | null;
  isAuthenticated: boolean;
}

export const useAuth = () => {
  const [auth, setAuth] = useState<AuthState>({
    token: null,
    userId: null,
    userType: null,
    isAuthenticated: false,
  });

  const login = async (userId: string, userType: "APP" | "WEB") => {
    try {
      const response = await axios.post(
        `${process.env.NEXT_PUBLIC_CHAT_API_URL}/auth/login`,
        {
          userId,
          userType,
        }
      );

      if (response.data.success) {
        const { token } = response.data.data;

        // í† í° ì €ì¥
        localStorage.setItem("chatToken", token);
        localStorage.setItem("userId", userId);
        localStorage.setItem("userType", userType);

        setAuth({
          token,
          userId,
          userType,
          isAuthenticated: true,
        });

        return { success: true };
      }
    } catch (error) {
      console.error("ë¡œê·¸ì¸ ì˜¤ë¥˜:", error);
      return { success: false, error: error.message };
    }
  };

  const logout = () => {
    localStorage.removeItem("chatToken");
    localStorage.removeItem("userId");
    localStorage.removeItem("userType");

    setAuth({
      token: null,
      userId: null,
      userType: null,
      isAuthenticated: false,
    });
  };

  // ì´ˆê¸° ë¡œë“œ ì‹œ í† í° ë³µì›
  useEffect(() => {
    const token = localStorage.getItem("chatToken");
    const userId = localStorage.getItem("userId");
    const userType = localStorage.getItem("userType") as "APP" | "WEB";

    if (token && userId && userType) {
      setAuth({
        token,
        userId,
        userType,
        isAuthenticated: true,
      });
    }
  }, []);

  return { auth, login, logout };
};
```

## 4. RESTful API ëª…ì„¸

### 4.1 ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ

**ìš”ì²­**:

- URL: `GET /chat/list`
- Headers: `Authorization: Bearer {token}`
- ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° (í…ŒìŠ¤íŠ¸ìš©, ì„ íƒì‚¬í•­):
  - `userId`: ì‚¬ìš©ì ID
  - `userType`: ì‚¬ìš©ì íƒ€ì… ("APP" ë˜ëŠ” "WEB")

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "ì±„íŒ…ë°© ëª©ë¡ì„ ì„±ê³µì ìœ¼ë¡œ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.",
  "data": [
    {
      "roomId": 1,
      "partnerName": "ìƒëŒ€ë°© ì´ë¦„",
      "lastMessage": "ë§ˆì§€ë§‰ ë©”ì‹œì§€ ë‚´ìš©",
      "lastMessageTime": "5ë¶„ ì „",
      "unreadCount": 3,
      "partnerStatus": "ONLINE"
    }
  ]
}
```

**React Hook ì˜ˆì‹œ**:

```typescript
// hooks/useChatRooms.ts
import { useState, useEffect } from "react";
import axios from "axios";
import { useAuth } from "./useAuth";

interface ChatRoom {
  roomId: number;
  partnerName: string;
  lastMessage: string | null;
  lastMessageTime: string | null;
  unreadCount: number;
  partnerStatus: "ONLINE" | "AWAY" | "BUSY" | "OFFLINE";
}

export const useChatRooms = () => {
  const { auth } = useAuth();
  const [rooms, setRooms] = useState<ChatRoom[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchChatRooms = async () => {
    if (!auth.isAuthenticated) return;

    setLoading(true);
    setError(null);

    try {
      const response = await axios.get(
        `${process.env.NEXT_PUBLIC_CHAT_API_URL}/chat/list`,
        {
          headers: {
            Authorization: `Bearer ${auth.token}`,
          },
        }
      );

      if (response.data.success) {
        setRooms(response.data.data);
      } else {
        setError(response.data.error || "ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨");
      }
    } catch (err) {
      setError(err.response?.data?.error || "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchChatRooms();
  }, [auth.isAuthenticated]);

  return { rooms, loading, error, refetch: fetchChatRooms };
};
```

### 4.2 ì±„íŒ…ë°© ë©”ì‹œì§€ ì¡°íšŒ (í˜ì´ì§•)

**ìš”ì²­**:

- URL: `GET /chat/room/{roomId}/messages`
- Headers: `Authorization: Bearer {token}`
- ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°:
  - `page`: í˜ì´ì§€ ë²ˆí˜¸ (ê¸°ë³¸ê°’: 1)
  - `limit`: í•œ í˜ì´ì§€ë‹¹ ë©”ì‹œì§€ ìˆ˜ (ê¸°ë³¸ê°’: 20)
  - `userId`: ì‚¬ìš©ì ID (í…ŒìŠ¤íŠ¸ìš©, ì„ íƒì‚¬í•­)
  - `userType`: ì‚¬ìš©ì íƒ€ì… (í…ŒìŠ¤íŠ¸ìš©, ì„ íƒì‚¬í•­)

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "ì±„íŒ… ë©”ì‹œì§€ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.",
  "data": {
    "messages": [
      {
        "messageId": 123,
        "senderType": "APP",
        "senderId": "user123",
        "message": "ì•ˆë…•í•˜ì„¸ìš”",
        "filePath": null,
        "isRead": true,
        "createdAt": "2025-01-27T15:30:00Z",
        "timeAgo": "5ë¶„ ì „"
      }
    ],
    "page": 1,
    "limit": 20,
    "total": 45,
    "isLastPage": false
  }
}
```

**React Hook ì˜ˆì‹œ**:

```typescript
// hooks/useChatMessages.ts
import { useState, useEffect, useCallback } from "react";
import axios from "axios";
import { useAuth } from "./useAuth";

interface ChatMessage {
  messageId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message: string | null;
  filePath: string | null;
  isRead: boolean;
  createdAt: string;
  timeAgo: string;
}

interface MessageResponse {
  messages: ChatMessage[];
  page: number;
  limit: number;
  total: number;
  isLastPage: boolean;
}

export const useChatMessages = (roomId: number) => {
  const { auth } = useAuth();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);

  const fetchMessages = useCallback(
    async (pageNum: number = 1, append: boolean = false) => {
      if (!auth.isAuthenticated || !roomId) return;

      setLoading(true);
      setError(null);

      try {
        const response = await axios.get(
          `${process.env.NEXT_PUBLIC_CHAT_API_URL}/chat/room/${roomId}/messages`,
          {
            headers: {
              Authorization: `Bearer ${auth.token}`,
            },
            params: {
              page: pageNum,
              limit: 20,
            },
          }
        );

        if (response.data.success) {
          const data: MessageResponse = response.data.data;

          if (append) {
            setMessages((prev) => [...prev, ...data.messages]);
          } else {
            setMessages(data.messages);
          }

          setHasMore(!data.isLastPage);
          setPage(pageNum);
        } else {
          setError(response.data.error || "ë©”ì‹œì§€ ì¡°íšŒ ì‹¤íŒ¨");
        }
      } catch (err) {
        setError(err.response?.data?.error || "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜");
      } finally {
        setLoading(false);
      }
    },
    [auth.isAuthenticated, auth.token, roomId]
  );

  const loadMore = () => {
    if (!loading && hasMore) {
      fetchMessages(page + 1, true);
    }
  };

  const addMessage = (newMessage: ChatMessage) => {
    setMessages((prev) => [newMessage, ...prev]);
  };

  const updateMessageReadStatus = (messageIds: number[]) => {
    setMessages((prev) =>
      prev.map((msg) =>
        messageIds.includes(msg.messageId) ? { ...msg, isRead: true } : msg
      )
    );
  };

  useEffect(() => {
    if (roomId) {
      setMessages([]);
      setPage(1);
      setHasMore(true);
      fetchMessages(1, false);
    }
  }, [roomId, fetchMessages]);

  return {
    messages,
    loading,
    error,
    hasMore,
    loadMore,
    addMessage,
    updateMessageReadStatus,
    refetch: () => fetchMessages(1, false),
  };
};
```

### 4.3 ì±„íŒ…ë°© ìƒì„±

**ìš”ì²­**:

- URL: `POST /chat/room`
- ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°:
  - `customerId`: ì›¹ ì‚¬ìš©ì ID
  - `userId`: ì•± ì‚¬ìš©ì ID

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "ì±„íŒ…ë°©ì´ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.",
  "data": {
    "roomId": 1,
    "isNew": true
  }
}
```

### 4.4 íŒŒì¼ ì—…ë¡œë“œ

**ìš”ì²­**:

- URL: `POST /chat/upload`
- Content-Type: `multipart/form-data`
- í¼ ë°ì´í„°:
  - `file`: ì—…ë¡œë“œí•  íŒŒì¼
  - `userId`: ì‚¬ìš©ì ID
  - `roomId`: ì±„íŒ…ë°© ID

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.",
  "data": {
    "filePath": "/uploads/20250510/123456.jpg"
  }
}
```

### 4.5 ì‚¬ìš©ì ìƒíƒœ ì¡°íšŒ

**ìš”ì²­**:

- URL: `GET /user/status/{userType}/{userId}`

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "ì‚¬ìš©ì ìƒíƒœë¥¼ ì„±ê³µì ìœ¼ë¡œ ì¡°íšŒí–ˆìŠµë‹ˆë‹¤.",
  "data": {
    "userId": "user123",
    "userType": "APP",
    "status": "ONLINE",
    "lastActivity": "2025-05-10T15:30:00"
  }
}
```

### 4.6 ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸

**ìš”ì²­**:

- URL: `PUT /user/status`
- Content-Type: `application/json`
- ìš”ì²­ ë³¸ë¬¸:

```json
{
  "userId": "user123",
  "userType": "APP",
  "status": "ONLINE" // "ONLINE", "AWAY", "BUSY", "OFFLINE" ì¤‘ í•˜ë‚˜
}
```

**ì‘ë‹µ**:

```json
{
  "success": true,
  "message": "ì‚¬ìš©ì ìƒíƒœê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.",
  "data": {
    "userId": "user123",
    "userType": "APP",
    "status": "ONLINE",
    "lastActivity": "2025-05-10T15:30:00"
  }
}
```

## 5. WebSocket API ëª…ì„¸

### 5.1 ì±„íŒ…ë°© WebSocket ì—°ê²°

**ì—°ê²° URL**:

- `wss://www.tigerbk.com/chat-api/ws/room/{roomId}?token={jwt_token}&lastMessageId={lastMessageId}`

**íŒŒë¼ë¯¸í„°**:

- `roomId`: ì±„íŒ…ë°© ID
- `token`: JWT ì¸ì¦ í† í° (í•„ìˆ˜)
- `lastMessageId` (ì„ íƒ): ë§ˆì§€ë§‰ìœ¼ë¡œ ë°›ì€ ë©”ì‹œì§€ ID (ì¬ì—°ê²° ì‹œ ìœ ìš©)

**React Hook ì˜ˆì‹œ**:

```typescript
// hooks/useChatWebSocket.ts
import { useEffect, useRef, useState, useCallback } from "react";
import { useAuth } from "./useAuth";

interface WebSocketMessage {
  type: string;
  messageId?: number;
  senderType?: "APP" | "WEB";
  senderId?: string;
  message?: string;
  filePath?: string;
  isRead?: boolean;
  createdAt?: string;
  timeAgo?: string;
  roomId?: number;
  isTyping?: boolean;
  userId?: string;
  userType?: string;
  success?: boolean;
  error?: string;
}

interface SendMessageData {
  roomId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message?: string;
  filePath?: string;
}

export const useChatWebSocket = (roomId: number, lastMessageId?: number) => {
  const { auth } = useAuth();
  const wsRef = useRef<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;

  // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ë“¤
  const messageHandlers = useRef<{
    onMessage?: (message: WebSocketMessage) => void;
    onTyping?: (data: {
      isTyping: boolean;
      userId: string;
      userType: string;
    }) => void;
    onMessageSent?: (data: {
      messageId: number;
      success: boolean;
      isRead: boolean;
    }) => void;
    onError?: (error: string) => void;
  }>({});

  const connect = useCallback(() => {
    if (!auth.isAuthenticated || !auth.token || !roomId) return;

    try {
      const wsUrl = new URL(
        `${process.env.NEXT_PUBLIC_CHAT_WS_URL}/ws/room/${roomId}`
      );
      wsUrl.searchParams.set("token", auth.token);
      if (lastMessageId) {
        wsUrl.searchParams.set("lastMessageId", lastMessageId.toString());
      }

      const ws = new WebSocket(wsUrl.toString());
      wsRef.current = ws;

      ws.onopen = () => {
        console.log("ì±„íŒ…ë°© WebSocket ì—°ê²°ë¨:", roomId);
        setIsConnected(true);
        setError(null);
        reconnectAttempts.current = 0;
      };

      ws.onmessage = (event) => {
        try {
          const data: WebSocketMessage = JSON.parse(event.data);

          switch (data.type) {
            case "connection":
              console.log("ì—°ê²° ì„±ê³µ:", data.message);
              break;
            case "message":
              messageHandlers.current.onMessage?.(data);
              break;
            case "typing_status":
              messageHandlers.current.onTyping?.({
                isTyping: data.isTyping || false,
                userId: data.userId || "",
                userType: (data.userType as "APP" | "WEB") || "APP",
              });
              break;
            case "message_sent":
              messageHandlers.current.onMessageSent?.({
                messageId: data.messageId || 0,
                success: data.success || false,
                isRead: data.isRead || false,
              });
              break;
            case "pong":
              // pingì— ëŒ€í•œ ì‘ë‹µ
              break;
            default:
              console.log("ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…:", data);
          }
        } catch (err) {
          console.error("WebSocket ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:", err);
        }
      };

      ws.onerror = (event) => {
        console.error("WebSocket ì˜¤ë¥˜:", event);
        setError("WebSocket ì—°ê²° ì˜¤ë¥˜");
        messageHandlers.current.onError?.("WebSocket ì—°ê²° ì˜¤ë¥˜");
      };

      ws.onclose = (event) => {
        console.log("WebSocket ì—°ê²° ì¢…ë£Œ:", event.code, event.reason);
        setIsConnected(false);
        wsRef.current = null;

        // ìë™ ì¬ì—°ê²° (ë¹„ì •ìƒ ì¢…ë£Œì¸ ê²½ìš°)
        if (
          event.code !== 1000 &&
          reconnectAttempts.current < maxReconnectAttempts
        ) {
          const delay = Math.pow(2, reconnectAttempts.current) * 1000; // ì§€ìˆ˜ ë°±ì˜¤í”„
          console.log(
            `${delay}ms í›„ ì¬ì—°ê²° ì‹œë„... (${
              reconnectAttempts.current + 1
            }/${maxReconnectAttempts})`
          );

          setTimeout(() => {
            reconnectAttempts.current++;
            connect();
          }, delay);
        }
      };
    } catch (err) {
      console.error("WebSocket ì—°ê²° ì‹¤íŒ¨:", err);
      setError("WebSocket ì—°ê²° ì‹¤íŒ¨");
    }
  }, [auth.isAuthenticated, auth.token, roomId, lastMessageId]);

  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close(1000, "ì •ìƒ ì¢…ë£Œ");
      wsRef.current = null;
    }
    setIsConnected(false);
  }, []);

  const sendMessage = useCallback((data: SendMessageData) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
      return true;
    }
    return false;
  }, []);

  const sendTyping = useCallback(
    (isTyping: boolean) => {
      if (
        wsRef.current &&
        wsRef.current.readyState === WebSocket.OPEN &&
        auth.userId &&
        auth.userType
      ) {
        wsRef.current.send(
          JSON.stringify({
            type: "typing",
            roomId,
            userId: auth.userId,
            userType: auth.userType,
            isTyping,
          })
        );
      }
    },
    [roomId, auth.userId, auth.userType]
  );

  const markAsRead = useCallback(
    (messageIds?: number[]) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(
          JSON.stringify({
            type: "mark_read",
            roomId,
            messageIds,
          })
        );
      }
    },
    [roomId]
  );

  // í•¸ë“¤ëŸ¬ ë“±ë¡ í•¨ìˆ˜ë“¤
  const onMessage = useCallback(
    (handler: (message: WebSocketMessage) => void) => {
      messageHandlers.current.onMessage = handler;
    },
    []
  );

  const onTyping = useCallback(
    (
      handler: (data: {
        isTyping: boolean;
        userId: string;
        userType: string;
      }) => void
    ) => {
      messageHandlers.current.onTyping = handler;
    },
    []
  );

  const onMessageSent = useCallback(
    (
      handler: (data: {
        messageId: number;
        success: boolean;
        isRead: boolean;
      }) => void
    ) => {
      messageHandlers.current.onMessageSent = handler;
    },
    []
  );

  const onError = useCallback((handler: (error: string) => void) => {
    messageHandlers.current.onError = handler;
  }, []);

  // ì—°ê²° ê´€ë¦¬
  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  // í˜ì´ì§€ ê°€ì‹œì„± ë³€ê²½ ì‹œ ì¬ì—°ê²°
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (
        document.visibilityState === "visible" &&
        !isConnected &&
        auth.isAuthenticated
      ) {
        connect();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () =>
      document.removeEventListener("visibilitychange", handleVisibilityChange);
  }, [connect, isConnected, auth.isAuthenticated]);

  return {
    isConnected,
    error,
    sendMessage,
    sendTyping,
    markAsRead,
    onMessage,
    onTyping,
    onMessageSent,
    onError,
    reconnect: connect,
    disconnect,
  };
};
```

**ìˆ˜ì‹  ë©”ì‹œì§€ í˜•ì‹**:

1. ë©”ì‹œì§€:

```json
{
  "type": "message",
  "messageId": 123,
  "roomId": 1,
  "senderType": "APP",
  "senderId": "user123",
  "message": "ì•ˆë…•í•˜ì„¸ìš”",
  "filePath": null,
  "isRead": false,
  "createdAt": "2025-05-10T15:30:00",
  "timeAgo": "ë°©ê¸ˆ ì „"
}
```

2. íƒ€ì´í•‘ ìƒíƒœ:

```json
{
  "type": "typing_status",
  "roomId": 1,
  "userType": "APP",
  "userId": "user123",
  "isTyping": true
}
```

3. ì—°ê²° ì„±ê³µ:

```json
{
  "success": true,
  "type": "connection",
  "message": "ì±„íŒ…ë°©ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.",
  "roomId": 1
}
```

**ì†¡ì‹  ë©”ì‹œì§€ í˜•ì‹**:

1. ë©”ì‹œì§€ ì „ì†¡:

```json
{
  "roomId": 1,
  "senderType": "APP",
  "senderId": "user123",
  "message": "ì•ˆë…•í•˜ì„¸ìš”",
  "filePath": null
}
```

2. íƒ€ì´í•‘ ìƒíƒœ ì „ì†¡:

```json
{
  "type": "typing",
  "roomId": 1,
  "userId": "user123",
  "userType": "APP",
  "isTyping": true
}
```

### 5.2 ì±„íŒ…ë°© ëª©ë¡ WebSocket ì—°ê²°

**ì—°ê²° URL**:

- `wss://www.tigerbk.com/chat-api/ws/rooms?userId={userId}&userType={userType}`

**íŒŒë¼ë¯¸í„°**:

- `userId`: ì‚¬ìš©ì ID
- `userType`: ì‚¬ìš©ì íƒ€ì… ("APP" ë˜ëŠ” "WEB")

**ìˆ˜ì‹  ë©”ì‹œì§€ í˜•ì‹**:

1. ì±„íŒ…ë°© ì—…ë°ì´íŠ¸:

```json
{
  "type": "room_update",
  "room": {
    "roomId": 1,
    "partnerId": "customer456",
    "partnerName": "ìƒëŒ€ë°© ì´ë¦„",
    "lastMessage": "ìƒˆ ë©”ì‹œì§€ ë‚´ìš©",
    "lastMessageTime": "2025-05-10T15:30:00",
    "timeAgo": "ë°©ê¸ˆ ì „",
    "unreadCount": 1
  }
}
```

2. ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸:

```json
{
  "type": "status_update",
  "userType": "APP",
  "userId": "user123",
  "status": "ONLINE"
}
```

3. ì—°ê²° ì„±ê³µ:

```json
{
  "success": true,
  "type": "connection",
  "message": "ì±„íŒ…ë°© ëª©ë¡ êµ¬ë…ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤."
}
```

**ì†¡ì‹  ë©”ì‹œì§€ í˜•ì‹**:

1. í•‘ ë©”ì‹œì§€:

```
ping
```

2. ì—°ê²° ì¢…ë£Œ:

```json
{
  "type": "close",
  "userId": "user123",
  "userType": "APP"
}
```

## 6. React.js/Next.js êµ¬í˜„ ì˜ˆì‹œ

### 6.1 ì±„íŒ…ë°© ëª©ë¡ ì»´í¬ë„ŒíŠ¸

```typescript
// components/ChatRoomList.tsx
import React, { useEffect } from "react";
import { useChatRooms } from "../hooks/useChatRooms";
import { useRoomListWebSocket } from "../hooks/useRoomListWebSocket";

interface ChatRoomListProps {
  onRoomSelect: (roomId: number) => void;
  selectedRoomId?: number;
}

export const ChatRoomList: React.FC<ChatRoomListProps> = ({
  onRoomSelect,
  selectedRoomId,
}) => {
  const { rooms, loading, error, refetch } = useChatRooms();
  const { isConnected, onRoomUpdate, onStatusUpdate } = useRoomListWebSocket();

  // WebSocket ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
  useEffect(() => {
    onRoomUpdate((updatedRoom) => {
      // ì±„íŒ…ë°© ëª©ë¡ ìë™ ì—…ë°ì´íŠ¸ëŠ” useChatRoomsì—ì„œ ì²˜ë¦¬
      refetch();
    });

    onStatusUpdate((statusData) => {
      // ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸ë„ refetchë¡œ ì²˜ë¦¬
      refetch();
    });
  }, [onRoomUpdate, onStatusUpdate, refetch]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <p className="text-red-600">ì˜¤ë¥˜: {error}</p>
        <button
          onClick={refetch}
          className="mt-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
        >
          ë‹¤ì‹œ ì‹œë„
        </button>
      </div>
    );
  }

  return (
    <div className="bg-white border-r border-gray-200 h-full">
      <div className="p-4 border-b border-gray-200">
        <h2 className="text-lg font-semibold text-gray-800">ì±„íŒ…ë°© ëª©ë¡</h2>
        <div className="flex items-center mt-2">
          <div
            className={`w-2 h-2 rounded-full mr-2 ${
              isConnected ? "bg-green-500" : "bg-red-500"
            }`}
          ></div>
          <span className="text-sm text-gray-600">
            {isConnected ? "ì—°ê²°ë¨" : "ì—°ê²° ëŠê¹€"}
          </span>
        </div>
      </div>

      <div className="overflow-y-auto h-full">
        {rooms.length === 0 ? (
          <div className="p-4 text-center text-gray-500">
            ì±„íŒ…ë°©ì´ ì—†ìŠµë‹ˆë‹¤.
          </div>
        ) : (
          rooms.map((room) => (
            <div
              key={room.roomId}
              onClick={() => onRoomSelect(room.roomId)}
              className={`p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 ${
                selectedRoomId === room.roomId
                  ? "bg-blue-50 border-blue-200"
                  : ""
              }`}
            >
              <div className="flex items-center justify-between">
                <div className="flex-1 min-w-0">
                  <div className="flex items-center">
                    <h3 className="text-sm font-medium text-gray-900 truncate">
                      {room.partnerName}
                    </h3>
                    <div
                      className={`ml-2 w-2 h-2 rounded-full ${
                        room.partnerStatus === "ONLINE"
                          ? "bg-green-500"
                          : room.partnerStatus === "AWAY"
                          ? "bg-yellow-500"
                          : room.partnerStatus === "BUSY"
                          ? "bg-red-500"
                          : "bg-gray-400"
                      }`}
                    ></div>
                  </div>
                  <p className="text-sm text-gray-500 truncate mt-1">
                    {room.lastMessage || "ë©”ì‹œì§€ê°€ ì—†ìŠµë‹ˆë‹¤."}
                  </p>
                  <p className="text-xs text-gray-400 mt-1">
                    {room.lastMessageTime}
                  </p>
                </div>
                {room.unreadCount > 0 && (
                  <div className="ml-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                    {room.unreadCount > 99 ? "99+" : room.unreadCount}
                  </div>
                )}
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};
```

### 6.2 ì±„íŒ…ë°© ì»´í¬ë„ŒíŠ¸

```typescript
// components/ChatRoom.tsx
import React, { useState, useEffect, useRef } from "react";
import { useChatMessages } from "../hooks/useChatMessages";
import { useChatWebSocket } from "../hooks/useChatWebSocket";
import { useAuth } from "../hooks/useAuth";
import { ChatMessage } from "./ChatMessage";
import { MessageInput } from "./MessageInput";
import { TypingIndicator } from "./TypingIndicator";

interface ChatRoomProps {
  roomId: number;
}

export const ChatRoom: React.FC<ChatRoomProps> = ({ roomId }) => {
  const { auth } = useAuth();
  const {
    messages,
    loading,
    error,
    hasMore,
    loadMore,
    addMessage,
    updateMessageReadStatus,
  } = useChatMessages(roomId);

  const {
    isConnected,
    sendMessage,
    sendTyping,
    markAsRead,
    onMessage,
    onTyping,
    onMessageSent,
    onError,
  } = useChatWebSocket(roomId);

  const [typingUsers, setTypingUsers] = useState<string[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);

  // WebSocket ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
  useEffect(() => {
    onMessage((message) => {
      addMessage(message);

      // ìƒëŒ€ë°© ë©”ì‹œì§€ì¸ ê²½ìš° ìë™ìœ¼ë¡œ ì½ìŒ ì²˜ë¦¬
      if (
        message.senderType !== auth.userType ||
        message.senderId !== auth.userId
      ) {
        setTimeout(() => {
          markAsRead([message.messageId]);
        }, 1000);
      }
    });

    onTyping(({ isTyping, userId, userType }) => {
      const userKey = `${userType}_${userId}`;

      setTypingUsers((prev) => {
        if (isTyping) {
          return prev.includes(userKey) ? prev : [...prev, userKey];
        } else {
          return prev.filter((u) => u !== userKey);
        }
      });

      // 3ì´ˆ í›„ ìë™ìœ¼ë¡œ íƒ€ì´í•‘ ìƒíƒœ ì œê±°
      if (isTyping) {
        setTimeout(() => {
          setTypingUsers((prev) => prev.filter((u) => u !== userKey));
        }, 3000);
      }
    });

    onMessageSent(({ messageId, success, isRead }) => {
      if (success) {
        console.log(`ë©”ì‹œì§€ ${messageId} ì „ì†¡ ì™„ë£Œ`);
        if (isRead) {
          updateMessageReadStatus([messageId]);
        }
      }
    });

    onError((error) => {
      console.error("WebSocket ì˜¤ë¥˜:", error);
    });
  }, [
    onMessage,
    onTyping,
    onMessageSent,
    onError,
    addMessage,
    markAsRead,
    updateMessageReadStatus,
    auth,
  ]);

  // ìŠ¤í¬ë¡¤ì„ ë§¨ ì•„ë˜ë¡œ ì´ë™
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // ìƒˆ ë©”ì‹œì§€ê°€ ì¶”ê°€ë  ë•Œ ìŠ¤í¬ë¡¤
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // ë©”ì‹œì§€ ì „ì†¡ í•¸ë“¤ëŸ¬
  const handleSendMessage = (message: string, filePath?: string) => {
    if (!auth.userId || !auth.userType) return;

    const success = sendMessage({
      roomId,
      senderType: auth.userType,
      senderId: auth.userId,
      message: message || undefined,
      filePath: filePath || undefined,
    });

    if (!success) {
      console.error("ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: WebSocket ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.");
    }
  };

  // íƒ€ì´í•‘ ìƒíƒœ ì „ì†¡
  const handleTyping = (isTyping: boolean) => {
    sendTyping(isTyping);
  };

  // ë¬´í•œ ìŠ¤í¬ë¡¤ ì²˜ë¦¬
  const handleScroll = () => {
    const container = messagesContainerRef.current;
    if (container && container.scrollTop === 0 && hasMore && !loading) {
      loadMore();
    }
  };

  if (error) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <p className="text-red-600 mb-4">ì˜¤ë¥˜: {error}</p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
          >
            ìƒˆë¡œê³ ì¹¨
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full bg-white">
      {/* í—¤ë” */}
      <div className="p-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-gray-800">
            ì±„íŒ…ë°© #{roomId}
          </h2>
          <div className="flex items-center">
            <div
              className={`w-2 h-2 rounded-full mr-2 ${
                isConnected ? "bg-green-500" : "bg-red-500"
              }`}
            ></div>
            <span className="text-sm text-gray-600">
              {isConnected ? "ì—°ê²°ë¨" : "ì—°ê²° ëŠê¹€"}
            </span>
          </div>
        </div>
      </div>

      {/* ë©”ì‹œì§€ ëª©ë¡ */}
      <div
        ref={messagesContainerRef}
        onScroll={handleScroll}
        className="flex-1 overflow-y-auto p-4 space-y-4"
      >
        {loading && (
          <div className="flex justify-center">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
          </div>
        )}

        {messages.map((message) => (
          <ChatMessage
            key={message.messageId}
            message={message}
            isOwn={
              message.senderType === auth.userType &&
              message.senderId === auth.userId
            }
          />
        ))}

        <TypingIndicator users={typingUsers} />
        <div ref={messagesEndRef} />
      </div>

      {/* ë©”ì‹œì§€ ì…ë ¥ */}
      <MessageInput
        onSendMessage={handleSendMessage}
        onTyping={handleTyping}
        disabled={!isConnected}
      />
    </div>
  );
};
```

### 6.2 ì±„íŒ… ë©”ì‹œì§€ ì „ì†¡/ìˆ˜ì‹ 

```javascript
// WebSocket ì—°ê²° ì„¤ì •
const roomId = 1;
const userId = "user123";
const userType = "APP";
const ws = new WebSocket(
  `wss://www.tigerbk.com/chat-api/ws/room/${roomId}?userId=${userId}&userType=${userType}`
);

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);

  if (data.type === "message") {
    // ìƒˆ ë©”ì‹œì§€ ì²˜ë¦¬
    addMessageToChat(data);
  } else if (data.type === "typing_status") {
    // íƒ€ì´í•‘ ìƒíƒœ ì²˜ë¦¬
    showTypingIndicator(data.isTyping);
  } else if (data.type === "message_sent") {
    // ë©”ì‹œì§€ ì „ì†¡ í™•ì¸
    console.log(`ë©”ì‹œì§€ ID ${data.messageId} ì „ì†¡ ì™„ë£Œ`);
  } else if (data.type === "messages_read_notification") {
    // ìƒëŒ€ë°©ì´ ë‚´ ë©”ì‹œì§€ë¥¼ ì½ì—ˆë‹¤ëŠ” ì•Œë¦¼ (ì±„íŒ…ë°© ë°–ì—ì„œ ë°›ëŠ” ê²½ìš°)
    console.log(
      `ì±„íŒ…ë°© ${data.roomId}ì—ì„œ ${data.count}ê°œ ë©”ì‹œì§€ê°€ ì½í˜”ìŠµë‹ˆë‹¤.`
    );
    // ì±„íŒ…ë°© ëª©ë¡ì˜ ì•ˆì½ì€ ë©”ì‹œì§€ ìˆ˜ ì—…ë°ì´íŠ¸
    updateChatRoomUnreadCount(data.roomId, 0); // ì½í˜”ìœ¼ë¯€ë¡œ 0ìœ¼ë¡œ ì„¤ì •
    // í† ìŠ¤íŠ¸ ì•Œë¦¼ í‘œì‹œ (ì„ íƒì‚¬í•­)
    showToastNotification(data.message);
  }
};

// ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
function sendMessage(message) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  // ë©”ì‹œì§€ ê²€ì¦
  const hasMessage = message && message.trim().length > 0;

  if (!hasMessage) {
    console.error("ë©”ì‹œì§€ ë‚´ìš©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.");
    return;
  }

  const messageData = {
    roomId: roomId,
    senderType: userType,
    senderId: userId,
    message: message.trim(),
  };

  ws.send(JSON.stringify(messageData));

  // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
  document.getElementById("messageInput").value = "";
}

// íƒ€ì´í•‘ ìƒíƒœ ì „ì†¡ í•¨ìˆ˜
function sendTypingStatus(isTyping) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  ws.send(
    JSON.stringify({
      type: "typing",
      roomId: roomId,
      userId: userId,
      userType: userType,
      isTyping: isTyping,
    })
  );
}

// ì±„íŒ…ë°©ì— ë©”ì‹œì§€ ì¶”ê°€ í•¨ìˆ˜
function addMessageToChat(message) {
  const chatContainer = document.getElementById("chatMessages");
  const messageElement = document.createElement("div");

  // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ì¸ì§€ ìƒëŒ€ë°©ì´ ë³´ë‚¸ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
  const isMine = message.senderType === userType && message.senderId === userId;

  messageElement.className = isMine ? "my-message" : "partner-message";

  // ë©”ì‹œì§€ ë‚´ìš© ì„¤ì •
  if (message.filePath) {
    // íŒŒì¼ ë©”ì‹œì§€
    messageElement.innerHTML = `
      <div class="file-message">
        <a href="${message.filePath}" target="_blank">
          <i class="fa fa-file"></i> ${message.filePath.split("/").pop()}
        </a>
      </div>
      <div class="message-meta">
        <span class="time">${message.timeAgo}</span>
        ${
          isMine
            ? `<span class="read-status">${
                message.isRead ? "ì½ìŒ" : "ì•ˆì½ìŒ"
              }</span>`
            : ""
        }
      </div>
    `;
  } else {
    // í…ìŠ¤íŠ¸ ë©”ì‹œì§€
    messageElement.innerHTML = `
      <div class="message-content">${message.message}</div>
      <div class="message-meta">
        <span class="time">${message.timeAgo}</span>
        ${
          isMine
            ? `<span class="read-status">${
                message.isRead ? "ì½ìŒ" : "ì•ˆì½ìŒ"
              }</span>`
            : ""
        }
      </div>
    `;
  }

  chatContainer.appendChild(messageElement);

  // ìŠ¤í¬ë¡¤ì„ ì•„ë˜ë¡œ ì´ë™
  chatContainer.scrollTop = chatContainer.scrollHeight;
}

// íƒ€ì´í•‘ í‘œì‹œê¸° ì²˜ë¦¬
function showTypingIndicator(isTyping) {
  const typingIndicator = document.getElementById("typingIndicator");
  typingIndicator.style.display = isTyping ? "block" : "none";
}

// íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
async function uploadFile() {
  const fileInput = document.getElementById("fileInput");
  if (!fileInput.files || fileInput.files.length === 0) return;

  const file = fileInput.files[0];
  const formData = new FormData();
  formData.append("file", file);
  formData.append("userId", userId);
  formData.append("roomId", roomId);

  try {
    const response = await fetch(
      "https://www.tigerbk.com/chat-api/chat/upload",
      {
        method: "POST",
        body: formData,
      }
    );

    const result = await response.json();

    if (result.success) {
      // íŒŒì¼ ê²½ë¡œê°€ í¬í•¨ëœ ë©”ì‹œì§€ ì „ì†¡ (ê°œì„ ëœ ë°©ì‹)
      sendFileMessage(result.data.filePath);
    } else {
      console.error("íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨:", result.error);
    }
  } catch (error) {
    console.error("íŒŒì¼ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
  }

  // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
  fileInput.value = "";
}

// íŒŒì¼ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
function sendFileMessage(filePath) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  // íŒŒì¼ ê²½ë¡œ ê²€ì¦
  const hasFile = filePath && filePath.trim().length > 0;

  if (!hasFile) {
    console.error("íŒŒì¼ ê²½ë¡œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.");
    return;
  }

  const messageData = {
    roomId: roomId,
    senderType: userType,
    senderId: userId,
    filePath: filePath.trim(),
  };

  ws.send(JSON.stringify(messageData));
}

function updateChatRoomUnreadCount(roomId, unreadCount) {
  // ì±„íŒ…ë°© ëª©ë¡ì—ì„œ í•´ë‹¹ ë°©ì˜ ì•ˆì½ì€ ë©”ì‹œì§€ ìˆ˜ ì—…ë°ì´íŠ¸
  const roomElement = document.querySelector(`[data-room-id="${roomId}"]`);
  if (roomElement) {
    const unreadBadge = roomElement.querySelector(".unread-badge");
    if (unreadBadge) {
      if (unreadCount > 0) {
        unreadBadge.textContent = unreadCount;
        unreadBadge.style.display = "block";
      } else {
        unreadBadge.style.display = "none";
      }
    }
  }
}

function showToastNotification(message) {
  // ê°„ë‹¨í•œ í† ìŠ¤íŠ¸ ì•Œë¦¼ í‘œì‹œ
  const toast = document.createElement("div");
  toast.className = "toast-notification";
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4CAF50;
    color: white;
    padding: 12px 20px;
    border-radius: 4px;
    z-index: 1000;
    animation: slideIn 0.3s ease-out;
  `;

  document.body.appendChild(toast);

  // 3ì´ˆ í›„ ìë™ ì œê±°
  setTimeout(() => {
    toast.style.animation = "slideOut 0.3s ease-in";
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  }, 3000);
}
```

### 6.3 ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸

```javascript
// ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
async function updateStatus(status) {
  try {
    const response = await fetch(
      "https://www.tigerbk.com/chat-api/user/status",
      {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          userId: userId,
          userType: userType,
          status: status, // "ONLINE", "AWAY", "BUSY", "OFFLINE"
        }),
      }
    );

    const result = await response.json();

    if (result.success) {
      console.log(`ìƒíƒœê°€ ${status}ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      // UI ì—…ë°ì´íŠ¸
      updateStatusUI(status);
    } else {
      console.error("ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", result.error);
    }
  } catch (error) {
    console.error("ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
  }
}

// í˜ì´ì§€ ê°€ì‹œì„± ë³€ê²½ ì‹œ ìë™ ìƒíƒœ ì—…ë°ì´íŠ¸
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    updateStatus("ONLINE");
  } else {
    updateStatus("AWAY");
  }
});
```

## 7. ì—ëŸ¬ ì²˜ë¦¬

API ìš”ì²­ ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì¼ë°˜ì ì¸ ì—ëŸ¬ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

- `400 Bad Request`: ì˜ëª»ëœ ìš”ì²­ í˜•ì‹ ë˜ëŠ” ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒë¼ë¯¸í„°
- `403 Forbidden`: ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ
- `404 Not Found`: ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
- `500 Internal Server Error`: ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜

ì—ëŸ¬ ì‘ë‹µì€ ë‹¤ìŒ í˜•ì‹ì„ ë”°ë¦…ë‹ˆë‹¤:

```json
{
  "success": false,
  "error": "ì—ëŸ¬ ë©”ì‹œì§€"
}
```

## 8. ì¶”ê°€ ê³ ë ¤ì‚¬í•­

### 8.1 WebSocket ì—°ê²° ìœ ì§€

WebSocket ì—°ê²°ì€ ë„¤íŠ¸ì›Œí¬ ìƒíƒœì— ë”°ë¼ ëŠê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—°ê²°ì´ ëŠì–´ì¡Œì„ ë•Œ ìë™ìœ¼ë¡œ ì¬ì—°ê²°ì„ ì‹œë„í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

```javascript
function setupWebSocket() {
  const ws = new WebSocket(url);

  ws.onclose = () => {
    console.log("WebSocket ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. 3ì´ˆ í›„ ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤.");
    setTimeout(setupWebSocket, 3000);
  };

  // ë‹¤ë¥¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •...

  return ws;
}
```

### 8.2 ì˜¤í”„ë¼ì¸ ìƒíƒœ ì²˜ë¦¬

ì‚¬ìš©ìê°€ ì˜¤í”„ë¼ì¸ ìƒíƒœì¼ ë•Œ ë©”ì‹œì§€ë¥¼ ì„ì‹œ ì €ì¥í•˜ê³ , ë‹¤ì‹œ ì˜¨ë¼ì¸ ìƒíƒœê°€ ë˜ë©´ ì „ì†¡í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ë©´ ë” ì¢‹ì€ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 8.3 íŒŒì¼ ë¯¸ë¦¬ë³´ê¸°

ì´ë¯¸ì§€ íŒŒì¼ì¸ ê²½ìš° ë¯¸ë¦¬ë³´ê¸°ë¥¼ ì œê³µí•˜ë©´ ì‚¬ìš©ì ê²½í—˜ì´ í–¥ìƒë©ë‹ˆë‹¤. íŒŒì¼ íƒ€ì…ì— ë”°ë¼ ì ì ˆí•œ ì•„ì´ì½˜ì´ë‚˜ ë¯¸ë¦¬ë³´ê¸°ë¥¼ í‘œì‹œí•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

## 7. ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬ ê°œì„  (React.js)

### 7.1 ê¸°ì¡´ ë¬¸ì œì 

- WebSocket ì—°ê²°ë§Œìœ¼ë¡œ ìë™ ì½ìŒ ì²˜ë¦¬
- ì‚¬ìš©ìê°€ ì‹¤ì œë¡œ ë©”ì‹œì§€ë¥¼ ë³´ì§€ ì•Šì•„ë„ ì½ìŒ ì²˜ë¦¬ë¨
- ì½ìŒ ìƒíƒœ ì—…ë°ì´íŠ¸ì˜ ë¶ˆëª…í™•ì„±

### 7.2 ê°œì„ ëœ ì½ìŒ ì²˜ë¦¬ Hook

```typescript
// hooks/useMessageReadStatus.ts
import { useEffect, useRef, useCallback } from "react";
import { useAuth } from "./useAuth";
import axios from "axios";

interface UseMessageReadStatusProps {
  roomId: number;
  onMarkAsRead?: (messageIds: number[]) => void;
}

export const useMessageReadStatus = ({
  roomId,
  onMarkAsRead,
}: UseMessageReadStatusProps) => {
  const { auth } = useAuth();
  const observerRef = useRef<IntersectionObserver | null>(null);
  const visibleMessages = useRef<Set<number>>(new Set());

  // ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬ API í˜¸ì¶œ
  const markMessagesAsRead = useCallback(
    async (messageIds: number[]) => {
      if (!auth.isAuthenticated || messageIds.length === 0) return;

      try {
        const response = await axios.post(
          `${process.env.NEXT_PUBLIC_CHAT_API_URL}/chat/messages/read`,
          {
            roomId,
            messageIds,
          },
          {
            headers: {
              Authorization: `Bearer ${auth.token}`,
            },
          }
        );

        if (response.data.success) {
          const { readMessageIds, unreadCount } = response.data.data;
          console.log(`${readMessageIds.length}ê°œ ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬ ì™„ë£Œ`);
          console.log(`ë‚¨ì€ ì•ˆì½ì€ ë©”ì‹œì§€: ${unreadCount}ê°œ`);

          // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— ì•Œë¦¼
          onMarkAsRead?.(readMessageIds);

          return { success: true, readMessageIds, unreadCount };
        }
      } catch (error) {
        console.error("ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
        return { success: false, error: error.message };
      }
    },
    [auth.isAuthenticated, auth.token, roomId, onMarkAsRead]
  );

  // Intersection Observer ì„¤ì •
  const setupIntersectionObserver = useCallback(() => {
    if (observerRef.current) {
      observerRef.current.disconnect();
    }

    observerRef.current = new IntersectionObserver(
      (entries) => {
        const newVisibleMessages: number[] = [];

        entries.forEach((entry) => {
          const messageElement = entry.target as HTMLElement;
          const messageId = parseInt(messageElement.dataset.messageId || "0");
          const isRead = messageElement.dataset.isRead === "true";
          const isMine = messageElement.classList.contains("own-message");

          if (entry.isIntersecting && messageId > 0) {
            // ìƒëŒ€ë°© ë©”ì‹œì§€ì´ê³  ì•„ì§ ì½ì§€ ì•Šì€ ê²½ìš°ë§Œ ì²˜ë¦¬
            if (!isMine && !isRead && !visibleMessages.current.has(messageId)) {
              visibleMessages.current.add(messageId);
              newVisibleMessages.push(messageId);

              // UIì—ì„œ ì¦‰ì‹œ ì½ìŒ ìƒíƒœë¡œ í‘œì‹œ (ë‚™ê´€ì  ì—…ë°ì´íŠ¸)
              messageElement.dataset.isRead = "true";
            }
          } else if (!entry.isIntersecting && messageId > 0) {
            visibleMessages.current.delete(messageId);
          }
        });

        // ì½ìŒ ì²˜ë¦¬í•  ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ ì„œë²„ì— ì „ì†¡
        if (newVisibleMessages.length > 0) {
          markMessagesAsRead(newVisibleMessages);
        }
      },
      {
        threshold: 0.5, // ë©”ì‹œì§€ì˜ 50%ê°€ ë³´ì´ë©´ ì½ìŒ ì²˜ë¦¬
        rootMargin: "0px 0px -50px 0px", // í•˜ë‹¨ 50px ì—¬ë°±
      }
    );

    return observerRef.current;
  }, [markMessagesAsRead]);

  // ë©”ì‹œì§€ ìš”ì†Œ ê´€ì°° ì‹œì‘
  const observeMessage = useCallback((element: HTMLElement) => {
    if (observerRef.current && element) {
      observerRef.current.observe(element);
    }
  }, []);

  // ë©”ì‹œì§€ ìš”ì†Œ ê´€ì°° ì¤‘ë‹¨
  const unobserveMessage = useCallback((element: HTMLElement) => {
    if (observerRef.current && element) {
      observerRef.current.unobserve(element);
    }
  }, []);

  // í˜ì´ì§€ ê°€ì‹œì„± ë³€ê²½ ì²˜ë¦¬
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        // í˜ì´ì§€ê°€ ë‹¤ì‹œ ë³´ì´ë©´ í˜„ì¬ í™”ë©´ì˜ ì•ˆì½ì€ ë©”ì‹œì§€ë“¤ ì²˜ë¦¬
        const visibleUnreadMessages = Array.from(
          document.querySelectorAll(
            '.message-item[data-is-read="false"]:not(.own-message)'
          )
        )
          .filter((el) => {
            const rect = el.getBoundingClientRect();
            return rect.top >= 0 && rect.bottom <= window.innerHeight;
          })
          .map((el) => parseInt((el as HTMLElement).dataset.messageId || "0"))
          .filter((id) => id > 0);

        if (visibleUnreadMessages.length > 0) {
          markMessagesAsRead(visibleUnreadMessages);
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () =>
      document.removeEventListener("visibilitychange", handleVisibilityChange);
  }, [markMessagesAsRead]);

  // ì´ˆê¸°í™” ë° ì •ë¦¬
  useEffect(() => {
    const observer = setupIntersectionObserver();

    return () => {
      if (observer) {
        observer.disconnect();
      }
      visibleMessages.current.clear();
    };
  }, [setupIntersectionObserver]);

  return {
    markMessagesAsRead,
    observeMessage,
    unobserveMessage,
  };
};
```

### ğŸ“¨ `message_sent` vs `messages_read` ì°¨ì´ì 

#### `message_sent` (ë©”ì‹œì§€ ì „ì†¡ í™•ì¸)

- **ë°›ëŠ” ì‚¬ëŒ**: ë©”ì‹œì§€ë¥¼ **ë³´ë‚¸ ì‚¬ëŒ**
- **ì „ì†¡ ì‹œì **: ë©”ì‹œì§€ ì „ì†¡ **ì¦‰ì‹œ**
- **ëª©ì **: ë©”ì‹œì§€ê°€ ì„œë²„ì— ì €ì¥ë˜ì—ˆìŒì„ í™•ì¸
- **í¬í•¨ ì •ë³´**: messageId, success, isRead (ìƒëŒ€ë°©ì´ í˜„ì¬ ì ‘ì† ì¤‘ì´ë©´ ì¦‰ì‹œ ì½ìŒ ì—¬ë¶€)

```javascript
// message_sent ì˜ˆì‹œ
{
  "type": "message_sent",
  "messageId": 123,
  "success": true,
  "isRead": false  // ìƒëŒ€ë°©ì´ ì•„ì§ ì½ì§€ ì•ŠìŒ
}
```

#### `messages_read` (í˜„ì¬ êµ¬ì¡° - ë¬¸ì œ ìˆìŒ)

- **ë°›ëŠ” ì‚¬ëŒ**: ë©”ì‹œì§€ë¥¼ **ë³´ë‚¸ ì‚¬ëŒ**
- **ì „ì†¡ ì‹œì **: ìƒëŒ€ë°©ì´ **ì±„íŒ…ë°©ì— ì ‘ì†í•  ë•Œ**
- **ë¬¸ì œì **: ì‹¤ì œë¡œ ì½ì§€ ì•Šì•˜ëŠ”ë°ë„ ì ‘ì†ë§Œìœ¼ë¡œ ì½ìŒ ì²˜ë¦¬
- **í¬í•¨ ì •ë³´**: ì½ìŒ ì²˜ë¦¬ëœ ë©”ì‹œì§€ ê°œìˆ˜ë§Œ ì œê³µ

```javascript
// í˜„ì¬ messages_read (ë¬¸ì œ ìˆëŠ” êµ¬ì¡°)
{
  "type": "messages_read",
  "roomId": 1,
  "readBy": "WEB_customer123",
  "count": 5  // êµ¬ì²´ì ì¸ ë©”ì‹œì§€ ì •ë³´ ì—†ìŒ
}
```

#### `message_read_update` (ê°œì„ ëœ êµ¬ì¡°)

- **ë°›ëŠ” ì‚¬ëŒ**: ë©”ì‹œì§€ë¥¼ **ë³´ë‚¸ ì‚¬ëŒ**
- **ì „ì†¡ ì‹œì **: ìƒëŒ€ë°©ì´ **ì‹¤ì œë¡œ ë©”ì‹œì§€ë¥¼ í™•ì¸í–ˆì„ ë•Œ**
- **ëª©ì **: ì •í™•í•œ ì½ìŒ ìƒíƒœ ì•Œë¦¼
- **í¬í•¨ ì •ë³´**: êµ¬ì²´ì ì¸ ë©”ì‹œì§€ ID ëª©ë¡

```javascript
// ê°œì„ ëœ message_read_update
{
  "type": "message_read_update",
  "roomId": 1,
  "messageIds": [123, 124, 125],
  "readBy": "WEB_customer123",
  "timestamp": "2025-01-27T10:30:00Z"
}
```

### ê°œì„ ëœ ì½ìŒ ì²˜ë¦¬ ë°©ì‹

#### 1. ëª…ì‹œì  ì½ìŒ í™•ì¸ API ì‚¬ìš©

```javascript
// ì‚¬ìš©ìê°€ ì‹¤ì œë¡œ ë©”ì‹œì§€ë¥¼ í™•ì¸í–ˆì„ ë•Œ í˜¸ì¶œ
async function markMessagesAsRead(roomId, messageIds) {
  try {
    const response = await fetch("/chat-api/chat/messages/read", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        roomId: roomId,
        messageIds: messageIds,
      }),
    });

    const result = await response.json();
    if (result.success) {
      console.log(
        `${result.data.readMessageIds.length}ê°œ ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬ ì™„ë£Œ`
      );
      console.log(`ë‚¨ì€ ì•ˆì½ì€ ë©”ì‹œì§€: ${result.data.unreadCount}ê°œ`);

      // UIì—ì„œ ì½ìŒ ìƒíƒœ ì—…ë°ì´íŠ¸
      updateMessageReadStatus(result.data.readMessageIds);
    }
  } catch (error) {
    console.error("ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
  }
}
```

#### 2. ìŠ¤í¬ë¡¤ ê¸°ë°˜ ì½ìŒ ì²˜ë¦¬

```javascript
// ë©”ì‹œì§€ê°€ í™”ë©´ì— ë³´ì´ëŠ” ì‹œì ì— ì½ìŒ ì²˜ë¦¬
function setupIntersectionObserver() {
  const observer = new IntersectionObserver(
    (entries) => {
      const visibleMessageIds = [];

      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const messageElement = entry.target;
          const messageId = parseInt(messageElement.dataset.messageId);
          const isRead = messageElement.dataset.isRead === "true";
          const isMine = messageElement.classList.contains("my-message");

          // ìƒëŒ€ë°© ë©”ì‹œì§€ì´ê³  ì•„ì§ ì½ì§€ ì•Šì€ ê²½ìš°ë§Œ ì²˜ë¦¬
          if (!isMine && !isRead) {
            visibleMessageIds.push(messageId);
            // UIì—ì„œ ì¦‰ì‹œ ì½ìŒ ìƒíƒœë¡œ í‘œì‹œ (ë‚™ê´€ì  ì—…ë°ì´íŠ¸)
            messageElement.dataset.isRead = "true";
          }
        }
      });

      // ì½ìŒ ì²˜ë¦¬í•  ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ ì„œë²„ì— ì „ì†¡
      if (visibleMessageIds.length > 0) {
        markMessagesAsRead(currentRoomId, visibleMessageIds);
      }
    },
    {
      threshold: 0.5, // ë©”ì‹œì§€ì˜ 50%ê°€ ë³´ì´ë©´ ì½ìŒ ì²˜ë¦¬
      rootMargin: "0px 0px -50px 0px", // í•˜ë‹¨ 50px ì—¬ë°±
    }
  );

  // ëª¨ë“  ë©”ì‹œì§€ ìš”ì†Œì— observer ì ìš©
  document.querySelectorAll(".message-item").forEach((message) => {
    observer.observe(message);
  });
}
```

#### 3. WebSocket ë©”ì‹œì§€ ì²˜ë¦¬ ê°œì„ 

```javascript
// WebSocket ë©”ì‹œì§€ ì²˜ë¦¬ì— ì½ìŒ ìƒíƒœ ì—…ë°ì´íŠ¸ ì¶”ê°€
chatSocket.onmessage = function (event) {
  const data = JSON.parse(event.data);

  switch (data.type) {
    case "message":
      // ìƒˆ ë©”ì‹œì§€ í‘œì‹œ
      displayChatMessage(data);

      // ìƒëŒ€ë°© ë©”ì‹œì§€ì¸ ê²½ìš° ìë™ìœ¼ë¡œ ì½ìŒ ì²˜ë¦¬ (í™”ë©´ì— ë³´ì´ëŠ” ê²½ìš°ë§Œ)
      if (data.senderType !== userType && isMessageVisible()) {
        markMessagesAsRead(data.roomId, [data.messageId]);
      }
      break;

    case "message_sent":
      // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ì˜ ì „ì†¡ í™•ì¸
      console.log(`ë©”ì‹œì§€ ${data.messageId} ì „ì†¡ ì™„ë£Œ`);
      if (data.isRead) {
        // ìƒëŒ€ë°©ì´ ì¦‰ì‹œ ì½ì—ˆìŒ (í˜„ì¬ ì±„íŒ…ë°©ì— ìˆìŒ)
        updateMyMessageReadStatus(data.messageId, true);
      }
      break;

    case "message_read_update":
      // ìƒëŒ€ë°©ì´ ë‚´ ë©”ì‹œì§€ë¥¼ ì½ì—ˆì„ ë•Œ (ê°œì„ ëœ ë²„ì „)
      updateMyMessagesReadStatus(data.messageIds);
      console.log(`ìƒëŒ€ë°©ì´ ${data.messageIds.length}ê°œ ë©”ì‹œì§€ë¥¼ ì½ì—ˆìŠµë‹ˆë‹¤.`);
      break;

    case "messages_read":
      // ê¸°ì¡´ ë²„ì „ (í˜¸í™˜ì„± ìœ ì§€)
      console.log(`ìƒëŒ€ë°©ì´ ${data.count}ê°œ ë©”ì‹œì§€ë¥¼ ì½ì—ˆìŠµë‹ˆë‹¤.`);
      // êµ¬ì²´ì ì¸ ë©”ì‹œì§€ ì •ë³´ê°€ ì—†ì–´ì„œ ì „ì²´ UI ìƒˆë¡œê³ ì¹¨ í•„ìš”
      refreshChatMessages();
      break;

    case "messages_read_notification":
      // ìƒëŒ€ë°©ì´ ë‚´ ë©”ì‹œì§€ë¥¼ ì½ì—ˆë‹¤ëŠ” ì•Œë¦¼ (ì±„íŒ…ë°© ë°–ì—ì„œ ë°›ëŠ” ê²½ìš°)
      console.log(
        `ì±„íŒ…ë°© ${data.roomId}ì—ì„œ ${data.count}ê°œ ë©”ì‹œì§€ê°€ ì½í˜”ìŠµë‹ˆë‹¤.`
      );
      // ì±„íŒ…ë°© ëª©ë¡ì˜ ì•ˆì½ì€ ë©”ì‹œì§€ ìˆ˜ ì—…ë°ì´íŠ¸
      updateChatRoomUnreadCount(data.roomId, 0); // ì½í˜”ìœ¼ë¯€ë¡œ 0ìœ¼ë¡œ ì„¤ì •
      // í† ìŠ¤íŠ¸ ì•Œë¦¼ í‘œì‹œ (ì„ íƒì‚¬í•­)
      showToastNotification(data.message);
      break;
  }
};

function updateMyMessageReadStatus(messageId, isRead) {
  const messageElement = document.querySelector(
    `[data-message-id="${messageId}"]`
  );
  if (messageElement && messageElement.classList.contains("my-message")) {
    const readStatus = messageElement.querySelector(".read-status");
    if (readStatus) {
      readStatus.textContent = isRead ? "ì½ìŒ" : "ì•ˆì½ìŒ";
      readStatus.classList.toggle("read", isRead);
    }
  }
}

function updateMyMessagesReadStatus(messageIds) {
  messageIds.forEach((messageId) => {
    updateMyMessageReadStatus(messageId, true);
  });
}
```

#### 4. ì±„íŒ…ë°© ì§„ì… ì‹œ ì½ìŒ ì²˜ë¦¬

```javascript
// ì±„íŒ…ë°© ì§„ì… ì‹œ í™”ë©´ì— ë³´ì´ëŠ” ë©”ì‹œì§€ë“¤ ì½ìŒ ì²˜ë¦¬
function onChatRoomEnter(roomId) {
  // ì ì‹œ í›„ í™”ë©´ì— ë Œë”ë§ëœ ë©”ì‹œì§€ë“¤ í™•ì¸
  setTimeout(() => {
    const unreadMessages = document.querySelectorAll(
      '.partner-message[data-is-read="false"]'
    );
    const messageIds = Array.from(unreadMessages).map((msg) =>
      parseInt(msg.dataset.messageId)
    );

    if (messageIds.length > 0) {
      markMessagesAsRead(roomId, messageIds);
    }
  }, 500);
}
```

#### 5. í˜ì´ì§€ ê°€ì‹œì„± API í™œìš©

```javascript
// í˜ì´ì§€ê°€ ë³´ì´ì§€ ì•Šì„ ë•ŒëŠ” ì½ìŒ ì²˜ë¦¬ ì¤‘ë‹¨
let isPageVisible = true;

document.addEventListener("visibilitychange", () => {
  isPageVisible = !document.hidden;

  if (isPageVisible) {
    // í˜ì´ì§€ê°€ ë‹¤ì‹œ ë³´ì´ë©´ í˜„ì¬ í™”ë©´ì˜ ì•ˆì½ì€ ë©”ì‹œì§€ë“¤ ì²˜ë¦¬
    checkAndMarkVisibleMessages();
  }
});

function isMessageVisible() {
  return isPageVisible && document.hasFocus();
}
```

### ê¶Œì¥ êµ¬í˜„ ìˆœì„œ

1. **ê¸°ì¡´ ìë™ ì½ìŒ ì²˜ë¦¬ ë¹„í™œì„±í™”**: WebSocket ì—°ê²° ì‹œ ìë™ ì½ìŒ ì²˜ë¦¬ ì œê±°
2. **ìƒˆë¡œìš´ ì½ìŒ API êµ¬í˜„**: `/chat/messages/read` ì—”ë“œí¬ì¸íŠ¸ í™œìš©
3. **í”„ë¡ íŠ¸ì—”ë“œ ì½ìŒ ë¡œì§ êµ¬í˜„**: Intersection Observer ê¸°ë°˜ ì½ìŒ ì²˜ë¦¬
4. **WebSocket ë©”ì‹œì§€ ì²˜ë¦¬ ê°œì„ **: `message_read_update` íƒ€ì… ì²˜ë¦¬ ì¶”ê°€
5. **ê¸°ì¡´ `messages_read` í˜¸í™˜ì„± ìœ ì§€**: ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜

ì´ë ‡ê²Œ ê°œì„ í•˜ë©´ ì‚¬ìš©ìì˜ ì‹¤ì œ í–‰ë™ê³¼ ì½ìŒ ìƒíƒœê°€ ì •í™•íˆ ì¼ì¹˜í•˜ê²Œ ë©ë‹ˆë‹¤.

## 8. Next.js í”„ë¡œì íŠ¸ êµ¬ì¡° ì˜ˆì‹œ

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ chat/
â”‚   â”‚   â”œâ”€â”€ ChatRoom.tsx
â”‚   â”‚   â”œâ”€â”€ ChatRoomList.tsx
â”‚   â”‚   â”œâ”€â”€ ChatMessage.tsx
â”‚   â”‚   â”œâ”€â”€ MessageInput.tsx
â”‚   â”‚   â””â”€â”€ TypingIndicator.tsx
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ Button.tsx
â”‚       â”œâ”€â”€ Input.tsx
â”‚       â””â”€â”€ Loading.tsx
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useChatRooms.ts
â”‚   â”œâ”€â”€ useChatMessages.ts
â”‚   â”œâ”€â”€ useChatWebSocket.ts
â”‚   â”œâ”€â”€ useRoomListWebSocket.ts
â”‚   â””â”€â”€ useMessageReadStatus.ts
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api.ts
â”‚   â”œâ”€â”€ websocket.ts
â”‚   â””â”€â”€ utils.ts
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ chat/
â”‚   â”‚   â””â”€â”€ [roomId].tsx
â”‚   â”œâ”€â”€ _app.tsx
â”‚   â””â”€â”€ index.tsx
â””â”€â”€ types/
    â”œâ”€â”€ auth.ts
    â”œâ”€â”€ chat.ts
    â””â”€â”€ api.ts
```

## 9. TypeScript íƒ€ì… ì •ì˜

```typescript
// types/chat.ts
export interface ChatRoom {
  roomId: number;
  partnerName: string;
  lastMessage: string | null;
  lastMessageTime: string | null;
  unreadCount: number;
  partnerStatus: "ONLINE" | "AWAY" | "BUSY" | "OFFLINE";
}

export interface ChatMessage {
  messageId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message: string | null;
  filePath: string | null;
  isRead: boolean;
  createdAt: string;
  timeAgo: string;
}

export interface SendMessageData {
  roomId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message?: string;
  filePath?: string;
}

export interface WebSocketMessage {
  type: "message" | "typing_status" | "message_sent" | "connection" | "pong";
  messageId?: number;
  senderType?: "APP" | "WEB";
  senderId?: string;
  message?: string;
  filePath?: string;
  isRead?: boolean;
  createdAt?: string;
  timeAgo?: string;
  roomId?: number;
  isTyping?: boolean;
  userId?: string;
  userType?: string;
  success?: boolean;
  error?: string;
}

// types/api.ts
export interface ApiResponse<T = any> {
  success: boolean;
  message?: string;
  data?: T;
  error?: string;
}

export interface PaginatedResponse<T> {
  messages: T[];
  page: number;
  limit: number;
  total: number;
  isLastPage: boolean;
}

// types/auth.ts
export interface AuthState {
  token: string | null;
  userId: string | null;
  userType: "APP" | "WEB" | null;
  isAuthenticated: boolean;
}

export interface LoginRequest {
  userId: string;
  userType: "APP" | "WEB";
}

export interface LoginResponse {
  token: string;
  expiresIn: number;
}
```

## 10. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜

```typescript
// lib/utils.ts
export const formatTimeAgo = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return "ë°©ê¸ˆ ì „";
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes}ë¶„ ì „`;
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours}ì‹œê°„ ì „`;
  } else {
    const days = Math.floor(diffInSeconds / 86400);
    if (days === 1) return "ì–´ì œ";
    if (days < 7) return `${days}ì¼ ì „`;
    return date.toLocaleDateString("ko-KR");
  }
};

export const isImageFile = (filePath: string): boolean => {
  const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"];
  return imageExtensions.some((ext) => filePath.toLowerCase().endsWith(ext));
};

export const getFileIcon = (filePath: string): string => {
  const extension = filePath.toLowerCase().split(".").pop();

  switch (extension) {
    case "pdf":
      return "ğŸ“„";
    case "doc":
    case "docx":
      return "ğŸ“";
    case "xls":
    case "xlsx":
      return "ğŸ“Š";
    case "ppt":
    case "pptx":
      return "ğŸ“‹";
    case "zip":
    case "rar":
      return "ğŸ—œï¸";
    case "mp4":
    case "avi":
    case "mov":
      return "ğŸ¥";
    case "mp3":
    case "wav":
      return "ğŸµ";
    default:
      return "ğŸ“";
  }
};

export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + "...";
};

// lib/api.ts
import axios, { AxiosInstance } from "axios";

class ChatApi {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: process.env.NEXT_PUBLIC_CHAT_API_URL,
      timeout: 10000,
    });

    // ìš”ì²­ ì¸í„°ì…‰í„° - í† í° ìë™ ì¶”ê°€
    this.api.interceptors.request.use((config) => {
      const token = localStorage.getItem("chatToken");
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // ì‘ë‹µ ì¸í„°ì…‰í„° - ì—ëŸ¬ ì²˜ë¦¬
    this.api.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          // í† í° ë§Œë£Œ ì‹œ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
          localStorage.removeItem("chatToken");
          localStorage.removeItem("userId");
          localStorage.removeItem("userType");
          window.location.href = "/login";
        }
        return Promise.reject(error);
      }
    );
  }

  // ë¡œê·¸ì¸
  async login(userId: string, userType: "APP" | "WEB") {
    const response = await this.api.post("/auth/login", { userId, userType });
    return response.data;
  }

  // ì±„íŒ…ë°© ëª©ë¡ ì¡°íšŒ
  async getChatRooms() {
    const response = await this.api.get("/chat/list");
    return response.data;
  }

  // ì±„íŒ…ë°© ë©”ì‹œì§€ ì¡°íšŒ
  async getChatMessages(roomId: number, page: number = 1, limit: number = 20) {
    const response = await this.api.get(`/chat/room/${roomId}/messages`, {
      params: { page, limit },
    });
    return response.data;
  }

  // ì±„íŒ…ë°© ìƒì„±
  async createChatRoom(data: {
    requestId: string;
    customerId: string;
    userId: string;
  }) {
    const response = await this.api.post("/chat/room", data);
    return response.data;
  }

  // íŒŒì¼ ì—…ë¡œë“œ
  async uploadFile(file: File, roomId: number) {
    const formData = new FormData();
    formData.append("file", file);
    formData.append("roomId", roomId.toString());

    const response = await this.api.post("/chat/upload", formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    });
    return response.data;
  }

  // ë©”ì‹œì§€ ì½ìŒ ì²˜ë¦¬
  async markMessagesAsRead(roomId: number, messageIds: number[]) {
    const response = await this.api.post("/chat/messages/read", {
      roomId,
      messageIds,
    });
    return response.data;
  }

  // ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸
  async updateUserStatus(status: "ONLINE" | "AWAY" | "BUSY" | "OFFLINE") {
    const response = await this.api.put("/user/status", {
      userId: localStorage.getItem("userId"),
      userType: localStorage.getItem("userType"),
      status,
    });
    return response.data;
  }
}

export const chatApi = new ChatApi();
```

## 11. ì„±ëŠ¥ ìµœì í™” íŒ

### 11.1 React.memo ì‚¬ìš©

```typescript
// components/ChatMessage.tsx
export const ChatMessage = React.memo<ChatMessageProps>(
  ({ message, isOwn }) => {
    // ì»´í¬ë„ŒíŠ¸ êµ¬í˜„
  },
  (prevProps, nextProps) => {
    return (
      prevProps.message.messageId === nextProps.message.messageId &&
      prevProps.message.isRead === nextProps.message.isRead &&
      prevProps.isOwn === nextProps.isOwn
    );
  }
);
```

### 11.2 ê°€ìƒí™” (Virtual Scrolling)

```bash
npm install react-window react-window-infinite-loader
```

### 11.3 ì´ë¯¸ì§€ ìµœì í™”

```typescript
// Next.js Image ì»´í¬ë„ŒíŠ¸ ì‚¬ìš©
import Image from "next/image";

const ChatImageMessage = ({ filePath }: { filePath: string }) => (
  <Image
    src={filePath}
    alt="ì±„íŒ… ì´ë¯¸ì§€"
    width={300}
    height={200}
    style={{ objectFit: "cover" }}
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,..."
  />
);
```

## 12. ë°°í¬ ë° í™˜ê²½ ì„¤ì •

### 12.1 í™˜ê²½ ë³€ìˆ˜ (.env.local, .env.production)

```env
NEXT_PUBLIC_CHAT_API_URL=https://www.tigerbk.com/chat-api
NEXT_PUBLIC_CHAT_WS_URL=wss://www.tigerbk.com/chat-api
NEXT_PUBLIC_MAX_FILE_SIZE=10485760
NEXT_PUBLIC_ALLOWED_FILE_TYPES=jpg,jpeg,png,gif,pdf,doc,docx
```

### 12.2 Next.js ì„¤ì • (next.config.js)

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  images: {
    domains: ["www.tigerbk.com"],
    formats: ["image/webp", "image/avif"],
  },
  experimental: {
    appDir: false, // Pages Router ì‚¬ìš© ì‹œ
  },
};

module.exports = nextConfig;
```

ì´ ê°€ì´ë“œëŠ” React.js/Next.js í™˜ê²½ì—ì„œ ì±„íŒ… ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. TypeScriptë¥¼ ì‚¬ìš©í•œ íƒ€ì… ì•ˆì „ì„±, React Hookì„ í™œìš©í•œ ìƒíƒœ ê´€ë¦¬, ê·¸ë¦¬ê³  ìµœì‹  ì›¹ ê¸°ìˆ ì„ í™œìš©í•œ ìµœì í™” ê¸°ë²•ë“¤ì„ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.
