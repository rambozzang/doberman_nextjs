# 채팅 시스템 프론트엔드 개발자 가이드 (React.js/Next.js)

이 문서는 채팅 시스템 API를 사용하여 React.js/Next.js 프론트엔드 애플리케이션을 개발하는 데 필요한 정보를 제공합니다.

## 1. API 개요

채팅 API는 RESTful API와 WebSocket을 조합하여 제공됩니다:

- **RESTful API**: 채팅방 목록 조회, 메시지 조회, 파일 업로드 등 일반 작업
- **WebSocket**: 실시간 채팅, 채팅방 목록 업데이트, 상태 변경 알림 등
- **JWT 인증**: Bearer 토큰 기반 인증 시스템

### 1.1 기본 URL

- **API Base URL**: `https://www.tigerbk.com/chat-api`
- **WebSocket Base URL**: `wss://www.tigerbk.com/chat-api`

### 1.2 React.js/Next.js 환경 설정

#### 필요한 의존성 설치

```bash
npm install axios socket.io-client
# 또는
yarn add axios socket.io-client
```

#### 환경 변수 설정 (.env.local)

```env
NEXT_PUBLIC_CHAT_API_URL=https://www.tigerbk.com/chat-api
NEXT_PUBLIC_CHAT_WS_URL=wss://www.tigerbk.com/chat-api
```

## 2. 표준 응답 형식

모든 HTTP API 응답은 다음 형식을 따릅니다:

```json
{
  "success": true|false,
  "message": "요청 처리 메시지",
  "data": { ... },  // 성공 시 결과 데이터
  "error": "에러 메시지"  // 실패 시 에러 메시지
}
```

## 3. 인증 시스템

채팅 시스템은 JWT(JSON Web Token) 기반 인증을 사용합니다.

### 3.1 인증 방식

- **HTTP API**: `Authorization: Bearer {token}` 헤더 사용
- **WebSocket**: 쿼리 파라미터로 토큰 전달 (`?token={token}`)
- **토큰 만료**: 7일 (자동 갱신 권장)

### 3.2 로그인 API

**요청**:

- URL: `POST /auth/login`
- Content-Type: `application/json`
- 요청 본문:

```json
{
  "userId": "user123",
  "userType": "APP" // "APP" 또는 "WEB"
}
```

**응답**:

```json
{
  "success": true,
  "message": "로그인이 성공했습니다.",
  "data": {
    "token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 604800
  }
}
```

### 3.3 React Hook 예시

```typescript
// hooks/useAuth.ts
import { useState, useEffect } from "react";
import axios from "axios";

interface AuthState {
  token: string | null;
  userId: string | null;
  userType: "APP" | "WEB" | null;
  isAuthenticated: boolean;
}

export const useAuth = () => {
  const [auth, setAuth] = useState<AuthState>({
    token: null,
    userId: null,
    userType: null,
    isAuthenticated: false,
  });

  const login = async (userId: string, userType: "APP" | "WEB") => {
    try {
      const response = await axios.post(
        `${process.env.NEXT_PUBLIC_CHAT_API_URL}/auth/login`,
        {
          userId,
          userType,
        }
      );

      if (response.data.success) {
        const { token } = response.data.data;

        // 토큰 저장
        localStorage.setItem("chatToken", token);
        localStorage.setItem("userId", userId);
        localStorage.setItem("userType", userType);

        setAuth({
          token,
          userId,
          userType,
          isAuthenticated: true,
        });

        return { success: true };
      }
    } catch (error) {
      console.error("로그인 오류:", error);
      return { success: false, error: error.message };
    }
  };

  const logout = () => {
    localStorage.removeItem("chatToken");
    localStorage.removeItem("userId");
    localStorage.removeItem("userType");

    setAuth({
      token: null,
      userId: null,
      userType: null,
      isAuthenticated: false,
    });
  };

  // 초기 로드 시 토큰 복원
  useEffect(() => {
    const token = localStorage.getItem("chatToken");
    const userId = localStorage.getItem("userId");
    const userType = localStorage.getItem("userType") as "APP" | "WEB";

    if (token && userId && userType) {
      setAuth({
        token,
        userId,
        userType,
        isAuthenticated: true,
      });
    }
  }, []);

  return { auth, login, logout };
};
```

## 4. RESTful API 명세

### 4.1 채팅방 목록 조회

**요청**:

- URL: `GET /chat/list`
- Headers: `Authorization: Bearer {token}`
- 쿼리 파라미터 (테스트용, 선택사항):
  - `userId`: 사용자 ID
  - `userType`: 사용자 타입 ("APP" 또는 "WEB")

**응답**:

```json
{
  "success": true,
  "message": "채팅방 목록을 성공적으로 조회했습니다.",
  "data": [
    {
      "roomId": 1,
      "partnerName": "상대방 이름",
      "lastMessage": "마지막 메시지 내용",
      "lastMessageTime": "5분 전",
      "unreadCount": 3,
      "partnerStatus": "ONLINE"
    }
  ]
}
```

**React Hook 예시**:

```typescript
// hooks/useChatRooms.ts
import { useState, useEffect } from "react";
import axios from "axios";
import { useAuth } from "./useAuth";

interface ChatRoom {
  roomId: number;
  partnerName: string;
  lastMessage: string | null;
  lastMessageTime: string | null;
  unreadCount: number;
  partnerStatus: "ONLINE" | "AWAY" | "BUSY" | "OFFLINE";
}

export const useChatRooms = () => {
  const { auth } = useAuth();
  const [rooms, setRooms] = useState<ChatRoom[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchChatRooms = async () => {
    if (!auth.isAuthenticated) return;

    setLoading(true);
    setError(null);

    try {
      const response = await axios.get(
        `${process.env.NEXT_PUBLIC_CHAT_API_URL}/chat/list`,
        {
          headers: {
            Authorization: `Bearer ${auth.token}`,
          },
        }
      );

      if (response.data.success) {
        setRooms(response.data.data);
      } else {
        setError(response.data.error || "채팅방 목록 조회 실패");
      }
    } catch (err) {
      setError(err.response?.data?.error || "네트워크 오류");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchChatRooms();
  }, [auth.isAuthenticated]);

  return { rooms, loading, error, refetch: fetchChatRooms };
};
```

### 4.2 채팅방 메시지 조회 (페이징)

**요청**:

- URL: `GET /chat/room/{roomId}/messages`
- Headers: `Authorization: Bearer {token}`
- 쿼리 파라미터:
  - `page`: 페이지 번호 (기본값: 1)
  - `limit`: 한 페이지당 메시지 수 (기본값: 20)
  - `userId`: 사용자 ID (테스트용, 선택사항)
  - `userType`: 사용자 타입 (테스트용, 선택사항)

**응답**:

```json
{
  "success": true,
  "message": "채팅 메시지를 성공적으로 조회했습니다.",
  "data": {
    "messages": [
      {
        "messageId": 123,
        "senderType": "APP",
        "senderId": "user123",
        "message": "안녕하세요",
        "filePath": null,
        "isRead": true,
        "createdAt": "2025-01-27T15:30:00Z",
        "timeAgo": "5분 전"
      }
    ],
    "page": 1,
    "limit": 20,
    "total": 45,
    "isLastPage": false
  }
}
```

**React Hook 예시**:

```typescript
// hooks/useChatMessages.ts
import { useState, useEffect, useCallback } from "react";
import axios from "axios";
import { useAuth } from "./useAuth";

interface ChatMessage {
  messageId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message: string | null;
  filePath: string | null;
  isRead: boolean;
  createdAt: string;
  timeAgo: string;
}

interface MessageResponse {
  messages: ChatMessage[];
  page: number;
  limit: number;
  total: number;
  isLastPage: boolean;
}

export const useChatMessages = (roomId: number) => {
  const { auth } = useAuth();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);

  const fetchMessages = useCallback(
    async (pageNum: number = 1, append: boolean = false) => {
      if (!auth.isAuthenticated || !roomId) return;

      setLoading(true);
      setError(null);

      try {
        const response = await axios.get(
          `${process.env.NEXT_PUBLIC_CHAT_API_URL}/chat/room/${roomId}/messages`,
          {
            headers: {
              Authorization: `Bearer ${auth.token}`,
            },
            params: {
              page: pageNum,
              limit: 20,
            },
          }
        );

        if (response.data.success) {
          const data: MessageResponse = response.data.data;

          if (append) {
            setMessages((prev) => [...prev, ...data.messages]);
          } else {
            setMessages(data.messages);
          }

          setHasMore(!data.isLastPage);
          setPage(pageNum);
        } else {
          setError(response.data.error || "메시지 조회 실패");
        }
      } catch (err) {
        setError(err.response?.data?.error || "네트워크 오류");
      } finally {
        setLoading(false);
      }
    },
    [auth.isAuthenticated, auth.token, roomId]
  );

  const loadMore = () => {
    if (!loading && hasMore) {
      fetchMessages(page + 1, true);
    }
  };

  const addMessage = (newMessage: ChatMessage) => {
    setMessages((prev) => [newMessage, ...prev]);
  };

  const updateMessageReadStatus = (messageIds: number[]) => {
    setMessages((prev) =>
      prev.map((msg) =>
        messageIds.includes(msg.messageId) ? { ...msg, isRead: true } : msg
      )
    );
  };

  useEffect(() => {
    if (roomId) {
      setMessages([]);
      setPage(1);
      setHasMore(true);
      fetchMessages(1, false);
    }
  }, [roomId, fetchMessages]);

  return {
    messages,
    loading,
    error,
    hasMore,
    loadMore,
    addMessage,
    updateMessageReadStatus,
    refetch: () => fetchMessages(1, false),
  };
};
```

### 4.3 채팅방 생성

**요청**:

- URL: `POST /chat/room`
- 쿼리 파라미터:
  - `customerId`: 웹 사용자 ID
  - `userId`: 앱 사용자 ID

**응답**:

```json
{
  "success": true,
  "message": "채팅방이 성공적으로 생성되었습니다.",
  "data": {
    "roomId": 1,
    "isNew": true
  }
}
```

### 4.4 파일 업로드

**요청**:

- URL: `POST /chat/upload`
- Content-Type: `multipart/form-data`
- 폼 데이터:
  - `file`: 업로드할 파일
  - `userId`: 사용자 ID
  - `roomId`: 채팅방 ID

**응답**:

```json
{
  "success": true,
  "message": "파일이 성공적으로 업로드되었습니다.",
  "data": {
    "filePath": "/uploads/20250510/123456.jpg"
  }
}
```

### 4.5 사용자 상태 조회

**요청**:

- URL: `GET /user/status/{userType}/{userId}`

**응답**:

```json
{
  "success": true,
  "message": "사용자 상태를 성공적으로 조회했습니다.",
  "data": {
    "userId": "user123",
    "userType": "APP",
    "status": "ONLINE",
    "lastActivity": "2025-05-10T15:30:00"
  }
}
```

### 4.6 사용자 상태 업데이트

**요청**:

- URL: `PUT /user/status`
- Content-Type: `application/json`
- 요청 본문:

```json
{
  "userId": "user123",
  "userType": "APP",
  "status": "ONLINE" // "ONLINE", "AWAY", "BUSY", "OFFLINE" 중 하나
}
```

**응답**:

```json
{
  "success": true,
  "message": "사용자 상태가 성공적으로 업데이트되었습니다.",
  "data": {
    "userId": "user123",
    "userType": "APP",
    "status": "ONLINE",
    "lastActivity": "2025-05-10T15:30:00"
  }
}
```

## 5. WebSocket API 명세

### 5.1 채팅방 WebSocket 연결

**연결 URL**:

- `wss://www.tigerbk.com/chat-api/ws/room/{roomId}?token={jwt_token}&lastMessageId={lastMessageId}`

**파라미터**:

- `roomId`: 채팅방 ID
- `token`: JWT 인증 토큰 (필수)
- `lastMessageId` (선택): 마지막으로 받은 메시지 ID (재연결 시 유용)

**React Hook 예시**:

```typescript
// hooks/useChatWebSocket.ts
import { useEffect, useRef, useState, useCallback } from "react";
import { useAuth } from "./useAuth";

interface WebSocketMessage {
  type: string;
  messageId?: number;
  senderType?: "APP" | "WEB";
  senderId?: string;
  message?: string;
  filePath?: string;
  isRead?: boolean;
  createdAt?: string;
  timeAgo?: string;
  roomId?: number;
  isTyping?: boolean;
  userId?: string;
  userType?: string;
  success?: boolean;
  error?: string;
}

interface SendMessageData {
  roomId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message?: string;
  filePath?: string;
}

export const useChatWebSocket = (roomId: number, lastMessageId?: number) => {
  const { auth } = useAuth();
  const wsRef = useRef<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;

  // 메시지 핸들러들
  const messageHandlers = useRef<{
    onMessage?: (message: WebSocketMessage) => void;
    onTyping?: (data: {
      isTyping: boolean;
      userId: string;
      userType: string;
    }) => void;
    onMessageSent?: (data: {
      messageId: number;
      success: boolean;
      isRead: boolean;
    }) => void;
    onError?: (error: string) => void;
  }>({});

  const connect = useCallback(() => {
    if (!auth.isAuthenticated || !auth.token || !roomId) return;

    try {
      const wsUrl = new URL(
        `${process.env.NEXT_PUBLIC_CHAT_WS_URL}/ws/room/${roomId}`
      );
      wsUrl.searchParams.set("token", auth.token);
      if (lastMessageId) {
        wsUrl.searchParams.set("lastMessageId", lastMessageId.toString());
      }

      const ws = new WebSocket(wsUrl.toString());
      wsRef.current = ws;

      ws.onopen = () => {
        console.log("채팅방 WebSocket 연결됨:", roomId);
        setIsConnected(true);
        setError(null);
        reconnectAttempts.current = 0;
      };

      ws.onmessage = (event) => {
        try {
          const data: WebSocketMessage = JSON.parse(event.data);

          switch (data.type) {
            case "connection":
              console.log("연결 성공:", data.message);
              break;
            case "message":
              messageHandlers.current.onMessage?.(data);
              break;
            case "typing_status":
              messageHandlers.current.onTyping?.({
                isTyping: data.isTyping || false,
                userId: data.userId || "",
                userType: (data.userType as "APP" | "WEB") || "APP",
              });
              break;
            case "message_sent":
              messageHandlers.current.onMessageSent?.({
                messageId: data.messageId || 0,
                success: data.success || false,
                isRead: data.isRead || false,
              });
              break;
            case "pong":
              // ping에 대한 응답
              break;
            default:
              console.log("알 수 없는 메시지 타입:", data);
          }
        } catch (err) {
          console.error("WebSocket 메시지 파싱 오류:", err);
        }
      };

      ws.onerror = (event) => {
        console.error("WebSocket 오류:", event);
        setError("WebSocket 연결 오류");
        messageHandlers.current.onError?.("WebSocket 연결 오류");
      };

      ws.onclose = (event) => {
        console.log("WebSocket 연결 종료:", event.code, event.reason);
        setIsConnected(false);
        wsRef.current = null;

        // 자동 재연결 (비정상 종료인 경우)
        if (
          event.code !== 1000 &&
          reconnectAttempts.current < maxReconnectAttempts
        ) {
          const delay = Math.pow(2, reconnectAttempts.current) * 1000; // 지수 백오프
          console.log(
            `${delay}ms 후 재연결 시도... (${
              reconnectAttempts.current + 1
            }/${maxReconnectAttempts})`
          );

          setTimeout(() => {
            reconnectAttempts.current++;
            connect();
          }, delay);
        }
      };
    } catch (err) {
      console.error("WebSocket 연결 실패:", err);
      setError("WebSocket 연결 실패");
    }
  }, [auth.isAuthenticated, auth.token, roomId, lastMessageId]);

  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close(1000, "정상 종료");
      wsRef.current = null;
    }
    setIsConnected(false);
  }, []);

  const sendMessage = useCallback((data: SendMessageData) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
      return true;
    }
    return false;
  }, []);

  const sendTyping = useCallback(
    (isTyping: boolean) => {
      if (
        wsRef.current &&
        wsRef.current.readyState === WebSocket.OPEN &&
        auth.userId &&
        auth.userType
      ) {
        wsRef.current.send(
          JSON.stringify({
            type: "typing",
            roomId,
            userId: auth.userId,
            userType: auth.userType,
            isTyping,
          })
        );
      }
    },
    [roomId, auth.userId, auth.userType]
  );

  const markAsRead = useCallback(
    (messageIds?: number[]) => {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(
          JSON.stringify({
            type: "mark_read",
            roomId,
            messageIds,
          })
        );
      }
    },
    [roomId]
  );

  // 핸들러 등록 함수들
  const onMessage = useCallback(
    (handler: (message: WebSocketMessage) => void) => {
      messageHandlers.current.onMessage = handler;
    },
    []
  );

  const onTyping = useCallback(
    (
      handler: (data: {
        isTyping: boolean;
        userId: string;
        userType: string;
      }) => void
    ) => {
      messageHandlers.current.onTyping = handler;
    },
    []
  );

  const onMessageSent = useCallback(
    (
      handler: (data: {
        messageId: number;
        success: boolean;
        isRead: boolean;
      }) => void
    ) => {
      messageHandlers.current.onMessageSent = handler;
    },
    []
  );

  const onError = useCallback((handler: (error: string) => void) => {
    messageHandlers.current.onError = handler;
  }, []);

  // 연결 관리
  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  // 페이지 가시성 변경 시 재연결
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (
        document.visibilityState === "visible" &&
        !isConnected &&
        auth.isAuthenticated
      ) {
        connect();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () =>
      document.removeEventListener("visibilitychange", handleVisibilityChange);
  }, [connect, isConnected, auth.isAuthenticated]);

  return {
    isConnected,
    error,
    sendMessage,
    sendTyping,
    markAsRead,
    onMessage,
    onTyping,
    onMessageSent,
    onError,
    reconnect: connect,
    disconnect,
  };
};
```

**수신 메시지 형식**:

1. 메시지:

```json
{
  "type": "message",
  "messageId": 123,
  "roomId": 1,
  "senderType": "APP",
  "senderId": "user123",
  "message": "안녕하세요",
  "filePath": null,
  "isRead": false,
  "createdAt": "2025-05-10T15:30:00",
  "timeAgo": "방금 전"
}
```

2. 타이핑 상태:

```json
{
  "type": "typing_status",
  "roomId": 1,
  "userType": "APP",
  "userId": "user123",
  "isTyping": true
}
```

3. 연결 성공:

```json
{
  "success": true,
  "type": "connection",
  "message": "채팅방에 연결되었습니다.",
  "roomId": 1
}
```

**송신 메시지 형식**:

1. 메시지 전송:

```json
{
  "roomId": 1,
  "senderType": "APP",
  "senderId": "user123",
  "message": "안녕하세요",
  "filePath": null
}
```

2. 타이핑 상태 전송:

```json
{
  "type": "typing",
  "roomId": 1,
  "userId": "user123",
  "userType": "APP",
  "isTyping": true
}
```

### 5.2 채팅방 목록 WebSocket 연결

**연결 URL**:

- `wss://www.tigerbk.com/chat-api/ws/rooms?userId={userId}&userType={userType}`

**파라미터**:

- `userId`: 사용자 ID
- `userType`: 사용자 타입 ("APP" 또는 "WEB")

**수신 메시지 형식**:

1. 채팅방 업데이트:

```json
{
  "type": "room_update",
  "room": {
    "roomId": 1,
    "partnerId": "customer456",
    "partnerName": "상대방 이름",
    "lastMessage": "새 메시지 내용",
    "lastMessageTime": "2025-05-10T15:30:00",
    "timeAgo": "방금 전",
    "unreadCount": 1
  }
}
```

2. 사용자 상태 업데이트:

```json
{
  "type": "status_update",
  "userType": "APP",
  "userId": "user123",
  "status": "ONLINE"
}
```

3. 연결 성공:

```json
{
  "success": true,
  "type": "connection",
  "message": "채팅방 목록 구독이 시작되었습니다."
}
```

**송신 메시지 형식**:

1. 핑 메시지:

```
ping
```

2. 연결 종료:

```json
{
  "type": "close",
  "userId": "user123",
  "userType": "APP"
}
```

## 6. React.js/Next.js 구현 예시

### 6.1 채팅방 목록 컴포넌트

```typescript
// components/ChatRoomList.tsx
import React, { useEffect } from "react";
import { useChatRooms } from "../hooks/useChatRooms";
import { useRoomListWebSocket } from "../hooks/useRoomListWebSocket";

interface ChatRoomListProps {
  onRoomSelect: (roomId: number) => void;
  selectedRoomId?: number;
}

export const ChatRoomList: React.FC<ChatRoomListProps> = ({
  onRoomSelect,
  selectedRoomId,
}) => {
  const { rooms, loading, error, refetch } = useChatRooms();
  const { isConnected, onRoomUpdate, onStatusUpdate } = useRoomListWebSocket();

  // WebSocket 이벤트 핸들러 설정
  useEffect(() => {
    onRoomUpdate((updatedRoom) => {
      // 채팅방 목록 자동 업데이트는 useChatRooms에서 처리
      refetch();
    });

    onStatusUpdate((statusData) => {
      // 사용자 상태 업데이트도 refetch로 처리
      refetch();
    });
  }, [onRoomUpdate, onStatusUpdate, refetch]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <p className="text-red-600">오류: {error}</p>
        <button
          onClick={refetch}
          className="mt-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
        >
          다시 시도
        </button>
      </div>
    );
  }

  return (
    <div className="bg-white border-r border-gray-200 h-full">
      <div className="p-4 border-b border-gray-200">
        <h2 className="text-lg font-semibold text-gray-800">채팅방 목록</h2>
        <div className="flex items-center mt-2">
          <div
            className={`w-2 h-2 rounded-full mr-2 ${
              isConnected ? "bg-green-500" : "bg-red-500"
            }`}
          ></div>
          <span className="text-sm text-gray-600">
            {isConnected ? "연결됨" : "연결 끊김"}
          </span>
        </div>
      </div>

      <div className="overflow-y-auto h-full">
        {rooms.length === 0 ? (
          <div className="p-4 text-center text-gray-500">
            채팅방이 없습니다.
          </div>
        ) : (
          rooms.map((room) => (
            <div
              key={room.roomId}
              onClick={() => onRoomSelect(room.roomId)}
              className={`p-4 border-b border-gray-100 cursor-pointer hover:bg-gray-50 ${
                selectedRoomId === room.roomId
                  ? "bg-blue-50 border-blue-200"
                  : ""
              }`}
            >
              <div className="flex items-center justify-between">
                <div className="flex-1 min-w-0">
                  <div className="flex items-center">
                    <h3 className="text-sm font-medium text-gray-900 truncate">
                      {room.partnerName}
                    </h3>
                    <div
                      className={`ml-2 w-2 h-2 rounded-full ${
                        room.partnerStatus === "ONLINE"
                          ? "bg-green-500"
                          : room.partnerStatus === "AWAY"
                          ? "bg-yellow-500"
                          : room.partnerStatus === "BUSY"
                          ? "bg-red-500"
                          : "bg-gray-400"
                      }`}
                    ></div>
                  </div>
                  <p className="text-sm text-gray-500 truncate mt-1">
                    {room.lastMessage || "메시지가 없습니다."}
                  </p>
                  <p className="text-xs text-gray-400 mt-1">
                    {room.lastMessageTime}
                  </p>
                </div>
                {room.unreadCount > 0 && (
                  <div className="ml-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                    {room.unreadCount > 99 ? "99+" : room.unreadCount}
                  </div>
                )}
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};
```

### 6.2 채팅방 컴포넌트

```typescript
// components/ChatRoom.tsx
import React, { useState, useEffect, useRef } from "react";
import { useChatMessages } from "../hooks/useChatMessages";
import { useChatWebSocket } from "../hooks/useChatWebSocket";
import { useAuth } from "../hooks/useAuth";
import { ChatMessage } from "./ChatMessage";
import { MessageInput } from "./MessageInput";
import { TypingIndicator } from "./TypingIndicator";

interface ChatRoomProps {
  roomId: number;
}

export const ChatRoom: React.FC<ChatRoomProps> = ({ roomId }) => {
  const { auth } = useAuth();
  const {
    messages,
    loading,
    error,
    hasMore,
    loadMore,
    addMessage,
    updateMessageReadStatus,
  } = useChatMessages(roomId);

  const {
    isConnected,
    sendMessage,
    sendTyping,
    markAsRead,
    onMessage,
    onTyping,
    onMessageSent,
    onError,
  } = useChatWebSocket(roomId);

  const [typingUsers, setTypingUsers] = useState<string[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);

  // WebSocket 이벤트 핸들러 설정
  useEffect(() => {
    onMessage((message) => {
      addMessage(message);

      // 상대방 메시지인 경우 자동으로 읽음 처리
      if (
        message.senderType !== auth.userType ||
        message.senderId !== auth.userId
      ) {
        setTimeout(() => {
          markAsRead([message.messageId]);
        }, 1000);
      }
    });

    onTyping(({ isTyping, userId, userType }) => {
      const userKey = `${userType}_${userId}`;

      setTypingUsers((prev) => {
        if (isTyping) {
          return prev.includes(userKey) ? prev : [...prev, userKey];
        } else {
          return prev.filter((u) => u !== userKey);
        }
      });

      // 3초 후 자동으로 타이핑 상태 제거
      if (isTyping) {
        setTimeout(() => {
          setTypingUsers((prev) => prev.filter((u) => u !== userKey));
        }, 3000);
      }
    });

    onMessageSent(({ messageId, success, isRead }) => {
      if (success) {
        console.log(`메시지 ${messageId} 전송 완료`);
        if (isRead) {
          updateMessageReadStatus([messageId]);
        }
      }
    });

    onError((error) => {
      console.error("WebSocket 오류:", error);
    });
  }, [
    onMessage,
    onTyping,
    onMessageSent,
    onError,
    addMessage,
    markAsRead,
    updateMessageReadStatus,
    auth,
  ]);

  // 스크롤을 맨 아래로 이동
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // 새 메시지가 추가될 때 스크롤
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // 메시지 전송 핸들러
  const handleSendMessage = (message: string, filePath?: string) => {
    if (!auth.userId || !auth.userType) return;

    const success = sendMessage({
      roomId,
      senderType: auth.userType,
      senderId: auth.userId,
      message: message || undefined,
      filePath: filePath || undefined,
    });

    if (!success) {
      console.error("메시지 전송 실패: WebSocket 연결이 끊어졌습니다.");
    }
  };

  // 타이핑 상태 전송
  const handleTyping = (isTyping: boolean) => {
    sendTyping(isTyping);
  };

  // 무한 스크롤 처리
  const handleScroll = () => {
    const container = messagesContainerRef.current;
    if (container && container.scrollTop === 0 && hasMore && !loading) {
      loadMore();
    }
  };

  if (error) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <p className="text-red-600 mb-4">오류: {error}</p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
          >
            새로고침
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full bg-white">
      {/* 헤더 */}
      <div className="p-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-gray-800">
            채팅방 #{roomId}
          </h2>
          <div className="flex items-center">
            <div
              className={`w-2 h-2 rounded-full mr-2 ${
                isConnected ? "bg-green-500" : "bg-red-500"
              }`}
            ></div>
            <span className="text-sm text-gray-600">
              {isConnected ? "연결됨" : "연결 끊김"}
            </span>
          </div>
        </div>
      </div>

      {/* 메시지 목록 */}
      <div
        ref={messagesContainerRef}
        onScroll={handleScroll}
        className="flex-1 overflow-y-auto p-4 space-y-4"
      >
        {loading && (
          <div className="flex justify-center">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
          </div>
        )}

        {messages.map((message) => (
          <ChatMessage
            key={message.messageId}
            message={message}
            isOwn={
              message.senderType === auth.userType &&
              message.senderId === auth.userId
            }
          />
        ))}

        <TypingIndicator users={typingUsers} />
        <div ref={messagesEndRef} />
      </div>

      {/* 메시지 입력 */}
      <MessageInput
        onSendMessage={handleSendMessage}
        onTyping={handleTyping}
        disabled={!isConnected}
      />
    </div>
  );
};
```

### 6.2 채팅 메시지 전송/수신

```javascript
// WebSocket 연결 설정
const roomId = 1;
const userId = "user123";
const userType = "APP";
const ws = new WebSocket(
  `wss://www.tigerbk.com/chat-api/ws/room/${roomId}?userId=${userId}&userType=${userType}`
);

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);

  if (data.type === "message") {
    // 새 메시지 처리
    addMessageToChat(data);
  } else if (data.type === "typing_status") {
    // 타이핑 상태 처리
    showTypingIndicator(data.isTyping);
  } else if (data.type === "message_sent") {
    // 메시지 전송 확인
    console.log(`메시지 ID ${data.messageId} 전송 완료`);
  } else if (data.type === "messages_read_notification") {
    // 상대방이 내 메시지를 읽었다는 알림 (채팅방 밖에서 받는 경우)
    console.log(
      `채팅방 ${data.roomId}에서 ${data.count}개 메시지가 읽혔습니다.`
    );
    // 채팅방 목록의 안읽은 메시지 수 업데이트
    updateChatRoomUnreadCount(data.roomId, 0); // 읽혔으므로 0으로 설정
    // 토스트 알림 표시 (선택사항)
    showToastNotification(data.message);
  }
};

// 메시지 전송 함수
function sendMessage(message) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  // 메시지 검증
  const hasMessage = message && message.trim().length > 0;

  if (!hasMessage) {
    console.error("메시지 내용이 비어있습니다.");
    return;
  }

  const messageData = {
    roomId: roomId,
    senderType: userType,
    senderId: userId,
    message: message.trim(),
  };

  ws.send(JSON.stringify(messageData));

  // 입력 필드 초기화
  document.getElementById("messageInput").value = "";
}

// 타이핑 상태 전송 함수
function sendTypingStatus(isTyping) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  ws.send(
    JSON.stringify({
      type: "typing",
      roomId: roomId,
      userId: userId,
      userType: userType,
      isTyping: isTyping,
    })
  );
}

// 채팅방에 메시지 추가 함수
function addMessageToChat(message) {
  const chatContainer = document.getElementById("chatMessages");
  const messageElement = document.createElement("div");

  // 내가 보낸 메시지인지 상대방이 보낸 메시지인지 확인
  const isMine = message.senderType === userType && message.senderId === userId;

  messageElement.className = isMine ? "my-message" : "partner-message";

  // 메시지 내용 설정
  if (message.filePath) {
    // 파일 메시지
    messageElement.innerHTML = `
      <div class="file-message">
        <a href="${message.filePath}" target="_blank">
          <i class="fa fa-file"></i> ${message.filePath.split("/").pop()}
        </a>
      </div>
      <div class="message-meta">
        <span class="time">${message.timeAgo}</span>
        ${
          isMine
            ? `<span class="read-status">${
                message.isRead ? "읽음" : "안읽음"
              }</span>`
            : ""
        }
      </div>
    `;
  } else {
    // 텍스트 메시지
    messageElement.innerHTML = `
      <div class="message-content">${message.message}</div>
      <div class="message-meta">
        <span class="time">${message.timeAgo}</span>
        ${
          isMine
            ? `<span class="read-status">${
                message.isRead ? "읽음" : "안읽음"
              }</span>`
            : ""
        }
      </div>
    `;
  }

  chatContainer.appendChild(messageElement);

  // 스크롤을 아래로 이동
  chatContainer.scrollTop = chatContainer.scrollHeight;
}

// 타이핑 표시기 처리
function showTypingIndicator(isTyping) {
  const typingIndicator = document.getElementById("typingIndicator");
  typingIndicator.style.display = isTyping ? "block" : "none";
}

// 파일 업로드 처리
async function uploadFile() {
  const fileInput = document.getElementById("fileInput");
  if (!fileInput.files || fileInput.files.length === 0) return;

  const file = fileInput.files[0];
  const formData = new FormData();
  formData.append("file", file);
  formData.append("userId", userId);
  formData.append("roomId", roomId);

  try {
    const response = await fetch(
      "https://www.tigerbk.com/chat-api/chat/upload",
      {
        method: "POST",
        body: formData,
      }
    );

    const result = await response.json();

    if (result.success) {
      // 파일 경로가 포함된 메시지 전송 (개선된 방식)
      sendFileMessage(result.data.filePath);
    } else {
      console.error("파일 업로드 실패:", result.error);
    }
  } catch (error) {
    console.error("파일 업로드 중 오류 발생:", error);
  }

  // 파일 입력 초기화
  fileInput.value = "";
}

// 파일 메시지 전송 함수
function sendFileMessage(filePath) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  // 파일 경로 검증
  const hasFile = filePath && filePath.trim().length > 0;

  if (!hasFile) {
    console.error("파일 경로가 비어있습니다.");
    return;
  }

  const messageData = {
    roomId: roomId,
    senderType: userType,
    senderId: userId,
    filePath: filePath.trim(),
  };

  ws.send(JSON.stringify(messageData));
}

function updateChatRoomUnreadCount(roomId, unreadCount) {
  // 채팅방 목록에서 해당 방의 안읽은 메시지 수 업데이트
  const roomElement = document.querySelector(`[data-room-id="${roomId}"]`);
  if (roomElement) {
    const unreadBadge = roomElement.querySelector(".unread-badge");
    if (unreadBadge) {
      if (unreadCount > 0) {
        unreadBadge.textContent = unreadCount;
        unreadBadge.style.display = "block";
      } else {
        unreadBadge.style.display = "none";
      }
    }
  }
}

function showToastNotification(message) {
  // 간단한 토스트 알림 표시
  const toast = document.createElement("div");
  toast.className = "toast-notification";
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4CAF50;
    color: white;
    padding: 12px 20px;
    border-radius: 4px;
    z-index: 1000;
    animation: slideIn 0.3s ease-out;
  `;

  document.body.appendChild(toast);

  // 3초 후 자동 제거
  setTimeout(() => {
    toast.style.animation = "slideOut 0.3s ease-in";
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  }, 3000);
}
```

### 6.3 사용자 상태 업데이트

```javascript
// 사용자 상태 업데이트 함수
async function updateStatus(status) {
  try {
    const response = await fetch(
      "https://www.tigerbk.com/chat-api/user/status",
      {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          userId: userId,
          userType: userType,
          status: status, // "ONLINE", "AWAY", "BUSY", "OFFLINE"
        }),
      }
    );

    const result = await response.json();

    if (result.success) {
      console.log(`상태가 ${status}로 업데이트되었습니다.`);
      // UI 업데이트
      updateStatusUI(status);
    } else {
      console.error("상태 업데이트 실패:", result.error);
    }
  } catch (error) {
    console.error("상태 업데이트 중 오류 발생:", error);
  }
}

// 페이지 가시성 변경 시 자동 상태 업데이트
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    updateStatus("ONLINE");
  } else {
    updateStatus("AWAY");
  }
});
```

## 7. 에러 처리

API 요청 시 발생할 수 있는 일반적인 에러 코드는 다음과 같습니다:

- `400 Bad Request`: 잘못된 요청 형식 또는 유효하지 않은 파라미터
- `403 Forbidden`: 접근 권한 없음
- `404 Not Found`: 요청한 리소스가 존재하지 않음
- `500 Internal Server Error`: 서버 내부 오류

에러 응답은 다음 형식을 따릅니다:

```json
{
  "success": false,
  "error": "에러 메시지"
}
```

## 8. 추가 고려사항

### 8.1 WebSocket 연결 유지

WebSocket 연결은 네트워크 상태에 따라 끊길 수 있습니다. 연결이 끊어졌을 때 자동으로 재연결을 시도하는 로직을 구현하는 것이 좋습니다.

```javascript
function setupWebSocket() {
  const ws = new WebSocket(url);

  ws.onclose = () => {
    console.log("WebSocket 연결이 끊어졌습니다. 3초 후 재연결을 시도합니다.");
    setTimeout(setupWebSocket, 3000);
  };

  // 다른 이벤트 핸들러 설정...

  return ws;
}
```

### 8.2 오프라인 상태 처리

사용자가 오프라인 상태일 때 메시지를 임시 저장하고, 다시 온라인 상태가 되면 전송하는 기능을 구현하면 더 좋은 사용자 경험을 제공할 수 있습니다.

### 8.3 파일 미리보기

이미지 파일인 경우 미리보기를 제공하면 사용자 경험이 향상됩니다. 파일 타입에 따라 적절한 아이콘이나 미리보기를 표시하는 것이 좋습니다.

## 7. 메시지 읽음 처리 개선 (React.js)

### 7.1 기존 문제점

- WebSocket 연결만으로 자동 읽음 처리
- 사용자가 실제로 메시지를 보지 않아도 읽음 처리됨
- 읽음 상태 업데이트의 불명확성

### 7.2 개선된 읽음 처리 Hook

```typescript
// hooks/useMessageReadStatus.ts
import { useEffect, useRef, useCallback } from "react";
import { useAuth } from "./useAuth";
import axios from "axios";

interface UseMessageReadStatusProps {
  roomId: number;
  onMarkAsRead?: (messageIds: number[]) => void;
}

export const useMessageReadStatus = ({
  roomId,
  onMarkAsRead,
}: UseMessageReadStatusProps) => {
  const { auth } = useAuth();
  const observerRef = useRef<IntersectionObserver | null>(null);
  const visibleMessages = useRef<Set<number>>(new Set());

  // 메시지 읽음 처리 API 호출
  const markMessagesAsRead = useCallback(
    async (messageIds: number[]) => {
      if (!auth.isAuthenticated || messageIds.length === 0) return;

      try {
        const response = await axios.post(
          `${process.env.NEXT_PUBLIC_CHAT_API_URL}/chat/messages/read`,
          {
            roomId,
            messageIds,
          },
          {
            headers: {
              Authorization: `Bearer ${auth.token}`,
            },
          }
        );

        if (response.data.success) {
          const { readMessageIds, unreadCount } = response.data.data;
          console.log(`${readMessageIds.length}개 메시지 읽음 처리 완료`);
          console.log(`남은 안읽은 메시지: ${unreadCount}개`);

          // 상위 컴포넌트에 알림
          onMarkAsRead?.(readMessageIds);

          return { success: true, readMessageIds, unreadCount };
        }
      } catch (error) {
        console.error("메시지 읽음 처리 오류:", error);
        return { success: false, error: error.message };
      }
    },
    [auth.isAuthenticated, auth.token, roomId, onMarkAsRead]
  );

  // Intersection Observer 설정
  const setupIntersectionObserver = useCallback(() => {
    if (observerRef.current) {
      observerRef.current.disconnect();
    }

    observerRef.current = new IntersectionObserver(
      (entries) => {
        const newVisibleMessages: number[] = [];

        entries.forEach((entry) => {
          const messageElement = entry.target as HTMLElement;
          const messageId = parseInt(messageElement.dataset.messageId || "0");
          const isRead = messageElement.dataset.isRead === "true";
          const isMine = messageElement.classList.contains("own-message");

          if (entry.isIntersecting && messageId > 0) {
            // 상대방 메시지이고 아직 읽지 않은 경우만 처리
            if (!isMine && !isRead && !visibleMessages.current.has(messageId)) {
              visibleMessages.current.add(messageId);
              newVisibleMessages.push(messageId);

              // UI에서 즉시 읽음 상태로 표시 (낙관적 업데이트)
              messageElement.dataset.isRead = "true";
            }
          } else if (!entry.isIntersecting && messageId > 0) {
            visibleMessages.current.delete(messageId);
          }
        });

        // 읽음 처리할 메시지가 있으면 서버에 전송
        if (newVisibleMessages.length > 0) {
          markMessagesAsRead(newVisibleMessages);
        }
      },
      {
        threshold: 0.5, // 메시지의 50%가 보이면 읽음 처리
        rootMargin: "0px 0px -50px 0px", // 하단 50px 여백
      }
    );

    return observerRef.current;
  }, [markMessagesAsRead]);

  // 메시지 요소 관찰 시작
  const observeMessage = useCallback((element: HTMLElement) => {
    if (observerRef.current && element) {
      observerRef.current.observe(element);
    }
  }, []);

  // 메시지 요소 관찰 중단
  const unobserveMessage = useCallback((element: HTMLElement) => {
    if (observerRef.current && element) {
      observerRef.current.unobserve(element);
    }
  }, []);

  // 페이지 가시성 변경 처리
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        // 페이지가 다시 보이면 현재 화면의 안읽은 메시지들 처리
        const visibleUnreadMessages = Array.from(
          document.querySelectorAll(
            '.message-item[data-is-read="false"]:not(.own-message)'
          )
        )
          .filter((el) => {
            const rect = el.getBoundingClientRect();
            return rect.top >= 0 && rect.bottom <= window.innerHeight;
          })
          .map((el) => parseInt((el as HTMLElement).dataset.messageId || "0"))
          .filter((id) => id > 0);

        if (visibleUnreadMessages.length > 0) {
          markMessagesAsRead(visibleUnreadMessages);
        }
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () =>
      document.removeEventListener("visibilitychange", handleVisibilityChange);
  }, [markMessagesAsRead]);

  // 초기화 및 정리
  useEffect(() => {
    const observer = setupIntersectionObserver();

    return () => {
      if (observer) {
        observer.disconnect();
      }
      visibleMessages.current.clear();
    };
  }, [setupIntersectionObserver]);

  return {
    markMessagesAsRead,
    observeMessage,
    unobserveMessage,
  };
};
```

### 📨 `message_sent` vs `messages_read` 차이점

#### `message_sent` (메시지 전송 확인)

- **받는 사람**: 메시지를 **보낸 사람**
- **전송 시점**: 메시지 전송 **즉시**
- **목적**: 메시지가 서버에 저장되었음을 확인
- **포함 정보**: messageId, success, isRead (상대방이 현재 접속 중이면 즉시 읽음 여부)

```javascript
// message_sent 예시
{
  "type": "message_sent",
  "messageId": 123,
  "success": true,
  "isRead": false  // 상대방이 아직 읽지 않음
}
```

#### `messages_read` (현재 구조 - 문제 있음)

- **받는 사람**: 메시지를 **보낸 사람**
- **전송 시점**: 상대방이 **채팅방에 접속할 때**
- **문제점**: 실제로 읽지 않았는데도 접속만으로 읽음 처리
- **포함 정보**: 읽음 처리된 메시지 개수만 제공

```javascript
// 현재 messages_read (문제 있는 구조)
{
  "type": "messages_read",
  "roomId": 1,
  "readBy": "WEB_customer123",
  "count": 5  // 구체적인 메시지 정보 없음
}
```

#### `message_read_update` (개선된 구조)

- **받는 사람**: 메시지를 **보낸 사람**
- **전송 시점**: 상대방이 **실제로 메시지를 확인했을 때**
- **목적**: 정확한 읽음 상태 알림
- **포함 정보**: 구체적인 메시지 ID 목록

```javascript
// 개선된 message_read_update
{
  "type": "message_read_update",
  "roomId": 1,
  "messageIds": [123, 124, 125],
  "readBy": "WEB_customer123",
  "timestamp": "2025-01-27T10:30:00Z"
}
```

### 개선된 읽음 처리 방식

#### 1. 명시적 읽음 확인 API 사용

```javascript
// 사용자가 실제로 메시지를 확인했을 때 호출
async function markMessagesAsRead(roomId, messageIds) {
  try {
    const response = await fetch("/chat-api/chat/messages/read", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        roomId: roomId,
        messageIds: messageIds,
      }),
    });

    const result = await response.json();
    if (result.success) {
      console.log(
        `${result.data.readMessageIds.length}개 메시지 읽음 처리 완료`
      );
      console.log(`남은 안읽은 메시지: ${result.data.unreadCount}개`);

      // UI에서 읽음 상태 업데이트
      updateMessageReadStatus(result.data.readMessageIds);
    }
  } catch (error) {
    console.error("메시지 읽음 처리 오류:", error);
  }
}
```

#### 2. 스크롤 기반 읽음 처리

```javascript
// 메시지가 화면에 보이는 시점에 읽음 처리
function setupIntersectionObserver() {
  const observer = new IntersectionObserver(
    (entries) => {
      const visibleMessageIds = [];

      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const messageElement = entry.target;
          const messageId = parseInt(messageElement.dataset.messageId);
          const isRead = messageElement.dataset.isRead === "true";
          const isMine = messageElement.classList.contains("my-message");

          // 상대방 메시지이고 아직 읽지 않은 경우만 처리
          if (!isMine && !isRead) {
            visibleMessageIds.push(messageId);
            // UI에서 즉시 읽음 상태로 표시 (낙관적 업데이트)
            messageElement.dataset.isRead = "true";
          }
        }
      });

      // 읽음 처리할 메시지가 있으면 서버에 전송
      if (visibleMessageIds.length > 0) {
        markMessagesAsRead(currentRoomId, visibleMessageIds);
      }
    },
    {
      threshold: 0.5, // 메시지의 50%가 보이면 읽음 처리
      rootMargin: "0px 0px -50px 0px", // 하단 50px 여백
    }
  );

  // 모든 메시지 요소에 observer 적용
  document.querySelectorAll(".message-item").forEach((message) => {
    observer.observe(message);
  });
}
```

#### 3. WebSocket 메시지 처리 개선

```javascript
// WebSocket 메시지 처리에 읽음 상태 업데이트 추가
chatSocket.onmessage = function (event) {
  const data = JSON.parse(event.data);

  switch (data.type) {
    case "message":
      // 새 메시지 표시
      displayChatMessage(data);

      // 상대방 메시지인 경우 자동으로 읽음 처리 (화면에 보이는 경우만)
      if (data.senderType !== userType && isMessageVisible()) {
        markMessagesAsRead(data.roomId, [data.messageId]);
      }
      break;

    case "message_sent":
      // 내가 보낸 메시지의 전송 확인
      console.log(`메시지 ${data.messageId} 전송 완료`);
      if (data.isRead) {
        // 상대방이 즉시 읽었음 (현재 채팅방에 있음)
        updateMyMessageReadStatus(data.messageId, true);
      }
      break;

    case "message_read_update":
      // 상대방이 내 메시지를 읽었을 때 (개선된 버전)
      updateMyMessagesReadStatus(data.messageIds);
      console.log(`상대방이 ${data.messageIds.length}개 메시지를 읽었습니다.`);
      break;

    case "messages_read":
      // 기존 버전 (호환성 유지)
      console.log(`상대방이 ${data.count}개 메시지를 읽었습니다.`);
      // 구체적인 메시지 정보가 없어서 전체 UI 새로고침 필요
      refreshChatMessages();
      break;

    case "messages_read_notification":
      // 상대방이 내 메시지를 읽었다는 알림 (채팅방 밖에서 받는 경우)
      console.log(
        `채팅방 ${data.roomId}에서 ${data.count}개 메시지가 읽혔습니다.`
      );
      // 채팅방 목록의 안읽은 메시지 수 업데이트
      updateChatRoomUnreadCount(data.roomId, 0); // 읽혔으므로 0으로 설정
      // 토스트 알림 표시 (선택사항)
      showToastNotification(data.message);
      break;
  }
};

function updateMyMessageReadStatus(messageId, isRead) {
  const messageElement = document.querySelector(
    `[data-message-id="${messageId}"]`
  );
  if (messageElement && messageElement.classList.contains("my-message")) {
    const readStatus = messageElement.querySelector(".read-status");
    if (readStatus) {
      readStatus.textContent = isRead ? "읽음" : "안읽음";
      readStatus.classList.toggle("read", isRead);
    }
  }
}

function updateMyMessagesReadStatus(messageIds) {
  messageIds.forEach((messageId) => {
    updateMyMessageReadStatus(messageId, true);
  });
}
```

#### 4. 채팅방 진입 시 읽음 처리

```javascript
// 채팅방 진입 시 화면에 보이는 메시지들 읽음 처리
function onChatRoomEnter(roomId) {
  // 잠시 후 화면에 렌더링된 메시지들 확인
  setTimeout(() => {
    const unreadMessages = document.querySelectorAll(
      '.partner-message[data-is-read="false"]'
    );
    const messageIds = Array.from(unreadMessages).map((msg) =>
      parseInt(msg.dataset.messageId)
    );

    if (messageIds.length > 0) {
      markMessagesAsRead(roomId, messageIds);
    }
  }, 500);
}
```

#### 5. 페이지 가시성 API 활용

```javascript
// 페이지가 보이지 않을 때는 읽음 처리 중단
let isPageVisible = true;

document.addEventListener("visibilitychange", () => {
  isPageVisible = !document.hidden;

  if (isPageVisible) {
    // 페이지가 다시 보이면 현재 화면의 안읽은 메시지들 처리
    checkAndMarkVisibleMessages();
  }
});

function isMessageVisible() {
  return isPageVisible && document.hasFocus();
}
```

### 권장 구현 순서

1. **기존 자동 읽음 처리 비활성화**: WebSocket 연결 시 자동 읽음 처리 제거
2. **새로운 읽음 API 구현**: `/chat/messages/read` 엔드포인트 활용
3. **프론트엔드 읽음 로직 구현**: Intersection Observer 기반 읽음 처리
4. **WebSocket 메시지 처리 개선**: `message_read_update` 타입 처리 추가
5. **기존 `messages_read` 호환성 유지**: 점진적 마이그레이션

이렇게 개선하면 사용자의 실제 행동과 읽음 상태가 정확히 일치하게 됩니다.

## 8. Next.js 프로젝트 구조 예시

```
src/
├── components/
│   ├── chat/
│   │   ├── ChatRoom.tsx
│   │   ├── ChatRoomList.tsx
│   │   ├── ChatMessage.tsx
│   │   ├── MessageInput.tsx
│   │   └── TypingIndicator.tsx
│   └── ui/
│       ├── Button.tsx
│       ├── Input.tsx
│       └── Loading.tsx
├── hooks/
│   ├── useAuth.ts
│   ├── useChatRooms.ts
│   ├── useChatMessages.ts
│   ├── useChatWebSocket.ts
│   ├── useRoomListWebSocket.ts
│   └── useMessageReadStatus.ts
├── lib/
│   ├── api.ts
│   ├── websocket.ts
│   └── utils.ts
├── pages/
│   ├── api/
│   ├── chat/
│   │   └── [roomId].tsx
│   ├── _app.tsx
│   └── index.tsx
└── types/
    ├── auth.ts
    ├── chat.ts
    └── api.ts
```

## 9. TypeScript 타입 정의

```typescript
// types/chat.ts
export interface ChatRoom {
  roomId: number;
  partnerName: string;
  lastMessage: string | null;
  lastMessageTime: string | null;
  unreadCount: number;
  partnerStatus: "ONLINE" | "AWAY" | "BUSY" | "OFFLINE";
}

export interface ChatMessage {
  messageId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message: string | null;
  filePath: string | null;
  isRead: boolean;
  createdAt: string;
  timeAgo: string;
}

export interface SendMessageData {
  roomId: number;
  senderType: "APP" | "WEB";
  senderId: string;
  message?: string;
  filePath?: string;
}

export interface WebSocketMessage {
  type: "message" | "typing_status" | "message_sent" | "connection" | "pong";
  messageId?: number;
  senderType?: "APP" | "WEB";
  senderId?: string;
  message?: string;
  filePath?: string;
  isRead?: boolean;
  createdAt?: string;
  timeAgo?: string;
  roomId?: number;
  isTyping?: boolean;
  userId?: string;
  userType?: string;
  success?: boolean;
  error?: string;
}

// types/api.ts
export interface ApiResponse<T = any> {
  success: boolean;
  message?: string;
  data?: T;
  error?: string;
}

export interface PaginatedResponse<T> {
  messages: T[];
  page: number;
  limit: number;
  total: number;
  isLastPage: boolean;
}

// types/auth.ts
export interface AuthState {
  token: string | null;
  userId: string | null;
  userType: "APP" | "WEB" | null;
  isAuthenticated: boolean;
}

export interface LoginRequest {
  userId: string;
  userType: "APP" | "WEB";
}

export interface LoginResponse {
  token: string;
  expiresIn: number;
}
```

## 10. 유틸리티 함수

```typescript
// lib/utils.ts
export const formatTimeAgo = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return "방금 전";
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes}분 전`;
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours}시간 전`;
  } else {
    const days = Math.floor(diffInSeconds / 86400);
    if (days === 1) return "어제";
    if (days < 7) return `${days}일 전`;
    return date.toLocaleDateString("ko-KR");
  }
};

export const isImageFile = (filePath: string): boolean => {
  const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".svg"];
  return imageExtensions.some((ext) => filePath.toLowerCase().endsWith(ext));
};

export const getFileIcon = (filePath: string): string => {
  const extension = filePath.toLowerCase().split(".").pop();

  switch (extension) {
    case "pdf":
      return "📄";
    case "doc":
    case "docx":
      return "📝";
    case "xls":
    case "xlsx":
      return "📊";
    case "ppt":
    case "pptx":
      return "📋";
    case "zip":
    case "rar":
      return "🗜️";
    case "mp4":
    case "avi":
    case "mov":
      return "🎥";
    case "mp3":
    case "wav":
      return "🎵";
    default:
      return "📎";
  }
};

export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + "...";
};

// lib/api.ts
import axios, { AxiosInstance } from "axios";

class ChatApi {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: process.env.NEXT_PUBLIC_CHAT_API_URL,
      timeout: 10000,
    });

    // 요청 인터셉터 - 토큰 자동 추가
    this.api.interceptors.request.use((config) => {
      const token = localStorage.getItem("chatToken");
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // 응답 인터셉터 - 에러 처리
    this.api.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          // 토큰 만료 시 로그아웃 처리
          localStorage.removeItem("chatToken");
          localStorage.removeItem("userId");
          localStorage.removeItem("userType");
          window.location.href = "/login";
        }
        return Promise.reject(error);
      }
    );
  }

  // 로그인
  async login(userId: string, userType: "APP" | "WEB") {
    const response = await this.api.post("/auth/login", { userId, userType });
    return response.data;
  }

  // 채팅방 목록 조회
  async getChatRooms() {
    const response = await this.api.get("/chat/list");
    return response.data;
  }

  // 채팅방 메시지 조회
  async getChatMessages(roomId: number, page: number = 1, limit: number = 20) {
    const response = await this.api.get(`/chat/room/${roomId}/messages`, {
      params: { page, limit },
    });
    return response.data;
  }

  // 채팅방 생성
  async createChatRoom(data: {
    requestId: string;
    customerId: string;
    userId: string;
  }) {
    const response = await this.api.post("/chat/room", data);
    return response.data;
  }

  // 파일 업로드
  async uploadFile(file: File, roomId: number) {
    const formData = new FormData();
    formData.append("file", file);
    formData.append("roomId", roomId.toString());

    const response = await this.api.post("/chat/upload", formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    });
    return response.data;
  }

  // 메시지 읽음 처리
  async markMessagesAsRead(roomId: number, messageIds: number[]) {
    const response = await this.api.post("/chat/messages/read", {
      roomId,
      messageIds,
    });
    return response.data;
  }

  // 사용자 상태 업데이트
  async updateUserStatus(status: "ONLINE" | "AWAY" | "BUSY" | "OFFLINE") {
    const response = await this.api.put("/user/status", {
      userId: localStorage.getItem("userId"),
      userType: localStorage.getItem("userType"),
      status,
    });
    return response.data;
  }
}

export const chatApi = new ChatApi();
```

## 11. 성능 최적화 팁

### 11.1 React.memo 사용

```typescript
// components/ChatMessage.tsx
export const ChatMessage = React.memo<ChatMessageProps>(
  ({ message, isOwn }) => {
    // 컴포넌트 구현
  },
  (prevProps, nextProps) => {
    return (
      prevProps.message.messageId === nextProps.message.messageId &&
      prevProps.message.isRead === nextProps.message.isRead &&
      prevProps.isOwn === nextProps.isOwn
    );
  }
);
```

### 11.2 가상화 (Virtual Scrolling)

```bash
npm install react-window react-window-infinite-loader
```

### 11.3 이미지 최적화

```typescript
// Next.js Image 컴포넌트 사용
import Image from "next/image";

const ChatImageMessage = ({ filePath }: { filePath: string }) => (
  <Image
    src={filePath}
    alt="채팅 이미지"
    width={300}
    height={200}
    style={{ objectFit: "cover" }}
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,..."
  />
);
```

## 12. 배포 및 환경 설정

### 12.1 환경 변수 (.env.local, .env.production)

```env
NEXT_PUBLIC_CHAT_API_URL=https://www.tigerbk.com/chat-api
NEXT_PUBLIC_CHAT_WS_URL=wss://www.tigerbk.com/chat-api
NEXT_PUBLIC_MAX_FILE_SIZE=10485760
NEXT_PUBLIC_ALLOWED_FILE_TYPES=jpg,jpeg,png,gif,pdf,doc,docx
```

### 12.2 Next.js 설정 (next.config.js)

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  images: {
    domains: ["www.tigerbk.com"],
    formats: ["image/webp", "image/avif"],
  },
  experimental: {
    appDir: false, // Pages Router 사용 시
  },
};

module.exports = nextConfig;
```

이 가이드는 React.js/Next.js 환경에서 채팅 시스템을 구현하는 데 필요한 모든 정보를 제공합니다. TypeScript를 사용한 타입 안전성, React Hook을 활용한 상태 관리, 그리고 최신 웹 기술을 활용한 최적화 기법들을 포함하고 있습니다.
